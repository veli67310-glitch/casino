#!/usr/bin/env python3
"""
Enhanced Casino Bot with CryptoBot Integration and Max Bet Limits - FIXED VERSION
"""

import asyncio
import logging
import json
import time
import sys
import os
import warnings
from datetime import datetime, timedelta
import threading
import gc

# Suppress specific warnings
warnings.filterwarnings("ignore", message="coroutine.*was never awaited")
warnings.filterwarnings("ignore", category=RuntimeWarning)

# Enable tracemalloc with memory limit
import tracemalloc
tracemalloc.start(10)
from telegram import Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from telegram.error import TimedOut, NetworkError
import httpx

# Fix import errors
try:
    from casino_bot import MultiplayerCasino
    from config import BOT_TOKEN, CRYPTO_BOT_TOKEN, CRYPTO_TESTNET, PAYMENT_SETTINGS, VIP_LEVELS, CRYPTO_RATES, REQUIRED_GROUP_USERNAME, REQUIRED_GROUP_URL, REQUIRED_GROUP_ID, GAMES
    from menu_handlers import show_main_menu
    from solo_games import SoloGameEngine
    from admin_handlers import show_admin_settings

    # Optional imports
    try:
        from cryptobot_payment import CryptoBotPaymentProcessor, CasinoPaymentManager
        CRYPTO_AVAILABLE = True
    except ImportError:
        print("WARNING: CryptoBot module not found - payment system disabled")
        CRYPTO_AVAILABLE = False

except ImportError as e:
    print(f"ERROR: Critical Import Error: {e}")
    print("ERROR: Basic configuration files missing!")
    sys.exit(1)

# Import critical callback handler functions at global scope
try:
    from bonus_menu_handler import show_bonus_features_menu
    BONUS_MENU_AVAILABLE = True
except ImportError:
    print("WARNING: bonus_menu_handler not found")
    BONUS_MENU_AVAILABLE = False

try:
    from payment_handlers import show_payment_menu
    PAYMENT_HANDLERS_AVAILABLE = True
except ImportError:
    print("WARNING: payment_handlers not found")
    PAYMENT_HANDLERS_AVAILABLE = False

try:
    from game_handlers import handle_solo_game, handle_create_duel, handle_join_game
    from enhanced_game_handlers import handle_enhanced_solo_game
    from bonus_features import show_daily_spinner, show_fortune_wheel, show_mystery_box, show_achievement_showcase
    from other_handlers import (show_daily_quests, show_achievements, show_leaderboard, show_tournaments, show_friends,
                               show_simple_daily_quests, show_simple_achievements, show_simple_leaderboard,
                               show_simple_friends_menu, show_tournament_menu, show_events_menu,
                               show_add_friend_menu, show_friend_requests_menu, handle_accept_friend, handle_reject_friend,
                               handle_create_tournament, handle_join_tournament)
    from solana_handlers import (show_solana_payment_menu, show_solana_deposit_menu,
                               handle_solana_deposit, show_solana_withdraw_menu, handle_wallet_selection,
                               show_withdrawal_wallet_input, process_solana_withdrawal,
                               show_solana_help, check_solana_deposit_status,
                               check_solana_withdrawal_status, show_user_wallet_stats,
                               show_cryptobot_payment_menu)
    from solana_admin import (show_solana_admin_panel, show_pending_withdrawals,
                            approve_withdrawal, reject_withdrawal, show_solana_rate_update,
                            update_solana_rate, show_solana_stats)
    from menu_handlers import (show_create_duel_menu, show_join_duel_menu, show_enhanced_profile,
                              show_enhanced_solo_games_menu, show_enhanced_solo_game_options, handle_simple_solo_game)
    from admin_handlers import (show_admin_panel, show_admin_statistics, show_admin_user_management,
                               show_admin_broadcast_menu, handle_admin_user_action)
    HANDLERS_AVAILABLE = True
except ImportError:
    print("WARNING: Some handler modules not found - using basic functionality")
    HANDLERS_AVAILABLE = False

# Logging setup - Fixed with UTF-8 encoding
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('casino_bot.log', encoding='utf-8'),
        logging.StreamHandler(sys.stdout)
    ]
)
# Fix console encoding for Windows
if sys.platform == 'win32':
    import os
    os.environ['PYTHONIOENCODING'] = 'utf-8'
logger = logging.getLogger(__name__)

def is_admin_user(user_id: int) -> bool:
    """Check if user is admin - reads from config.py"""
    from config import ADMIN_USER_IDS
    return user_id in ADMIN_USER_IDS

def is_group_chat(update: Update) -> bool:
    """Check if the current chat is a group or supergroup"""
    chat_type = update.effective_chat.type
    return chat_type in ['group', 'supergroup']

class EnhancedCasinoBot:
    """Enhanced Casino Bot with CryptoBot payments and max bet limits"""
    
    def __init__(self):
        try:
            self.casino = MultiplayerCasino()
            logger.info("SUCCESS: Casino system initialized")
        except Exception as e:
            logger.error(f"ERROR: Casino initialization failed: {e}")
            raise
        
        # Start CryptoBot handler - add error control
        if CRYPTO_AVAILABLE:
            try:
                self.crypto_processor = CryptoBotPaymentProcessor(CRYPTO_BOT_TOKEN, CRYPTO_TESTNET)
                self.payment_manager = CasinoPaymentManager(self.crypto_processor, self.casino.db)
                logger.info("SUCCESS: CryptoBot integration initialized")
            except Exception as e:
                logger.error(f"WARNING: CryptoBot initialization failed: {e}")
                self.crypto_processor = None
                self.payment_manager = None
        else:
            self.crypto_processor = None
            self.payment_manager = None
            logger.info("WARNING: CryptoBot module missing - payment system disabled")
        
        # Add payment manager to casino for easy access
        if self.payment_manager:
            self.casino.payment_manager = self.payment_manager
        
        # Initialize Solana payment system (lazy initialization)
        self.solana_system = None
        self._solana_initialized = False
        
        # Enhanced bet limits with user-specific calculation
        self.max_bet_limits = {
            'default': 100000,  # Default max bet
            'vip1': 250000,     # VIP 1 max bet
            'vip2': 500000,     # VIP 2 max bet  
            'vip3': 1000000,    # VIP 3 max bet
            'vip4': 2000000,    # VIP 4 max bet
            'vip5': 5000000,    # VIP 5 max bet
        }
        
        # High-performance group system for 100+ concurrent users
        try:
            from group_performance_optimizer import (
                initialize_group_performance, group_performance_manager, 
                optimized_group_handler
            )
            from group_performance_monitor import get_performance_monitor
            
            self.perf_manager, self.optimized_handler = initialize_group_performance()
            self.performance_monitor = get_performance_monitor()
            self.performance_monitor.start_monitoring()
            
            logger.info("High-performance group system with monitoring initialized")
        except ImportError:
            logger.warning("WARNING: Group performance optimizer not found - using legacy system")
            self.perf_manager = None
            self.optimized_handler = None
            self.performance_monitor = None
        
        # Legacy group game lock system (kept for compatibility)
        self.group_game_locks = {}  # chat_id: {'user_id': user_id, 'game_type': str, 'timestamp': time.time()}
        self.group_locks_lock = threading.Lock()  # Thread-safe access to group_game_locks
        
        # Performance cache for frequently accessed data
        self.cache = {}
        self.cache_expiry = {}  # Cache expiry times
        self.last_cache_cleanup = time.time()
        
        # Auto payment processing settings
        self.auto_payment_enabled = True
        self.payment_check_interval = 30  # seconds
        self.last_payment_check = 0
        
        # Transaction cache for performance - with limits
        self.pending_transactions = {}
        self.max_pending_transactions = 500
        
        # Bot health monitoring
        self.bot_start_time = datetime.now()
        self.total_commands_processed = 0
        
    def get_user_vip_level(self, user_id: int) -> int:
        """Get user's VIP level based on total deposits - with caching"""
        cache_key = f"vip_{user_id}"
        current_time = time.time()
        
        # Check cache first
        if cache_key in self.cache and current_time < self.cache_expiry.get(cache_key, 0):
            return self.cache[cache_key]
            
        if not self.payment_manager:
            return 0
            
        try:
            stats = self.payment_manager.get_user_payment_stats(user_id)
            total_deposited = stats['total_deposits']
            
            vip_level = 0
            for level, requirements in VIP_LEVELS.items():
                if total_deposited >= requirements['min_deposit']:
                    vip_level = level
            
            # Cache result for 5 minutes
            self.cache[cache_key] = vip_level
            self.cache_expiry[cache_key] = current_time + 300
            
            return vip_level
        except Exception as e:
            logger.error(f"VIP level calculation error: {e}")
            return 0
    
    def get_user_max_bet(self, user_id: int) -> int:
        """Get user's maximum bet limit based on VIP status"""
        vip_level = self.get_user_vip_level(user_id)
        return self.get_user_max_bet_by_vip(vip_level)
    
    def get_user_max_bet_by_vip(self, vip_level: int) -> int:
        """Get max bet by VIP level directly"""
        if vip_level >= 5:
            return self.max_bet_limits['vip5']
        elif vip_level >= 4:
            return self.max_bet_limits['vip4']
        elif vip_level >= 3:
            return self.max_bet_limits['vip3']
        elif vip_level >= 2:
            return self.max_bet_limits['vip2']
        elif vip_level >= 1:
            return self.max_bet_limits['vip1']
        else:
            return self.max_bet_limits['default']
    
    def create_keyboard(self, buttons):
        """Create inline keyboard for bot messages"""
        return self.casino.create_keyboard(buttons)
    
    def validate_bet_amount(self, user_id: int, bet_amount: int, user_balance: int) -> dict:
        """Enhanced bet validation with VIP-based limits and balance checks"""
        
        # Basic validation
        if bet_amount <= 0:
            return {
                'valid': False,
                'reason': "ERROR: Bet amount must be positive!"
            }
        
        # Basic balance check
        if bet_amount > user_balance:
            return {
                'valid': False,
                'reason': f"ğŸ’¸ Insufficient balance! Current: {user_balance:,} ğŸ»"
            }
        
        # Get user's max bet limit
        max_bet = self.get_user_max_bet(user_id)
        if bet_amount > max_bet:
            vip_level = self.get_user_vip_level(user_id)
            return {
                'valid': False,
                'reason': f"ğŸš« Your maximum bet limit: {max_bet:,} ğŸ» (VIP {vip_level})"
            }
        
        # Balance ratio check (max 10% of balance in single bet)
        max_balance_bet = int(user_balance * PAYMENT_SETTINGS.get('max_bet_ratio', 0.1))
        if bet_amount > max_balance_bet:
            return {
                'valid': False,
                'reason': f"WARNING: Maximum {int(PAYMENT_SETTINGS.get('max_bet_ratio', 0.1)*100)}% of balance can be bet: {max_balance_bet:,} ğŸ»"
            }
        
        # Use payment manager's additional checks if available
        if self.payment_manager:
            try:
                payment_check = self.payment_manager.check_bet_limits(user_id, bet_amount, user_balance)
                if not payment_check['allowed']:
                    return {
                        'valid': False,
                        'reason': payment_check['reason']
                    }
            except Exception as e:
                logger.error(f"Payment manager bet check error: {e}")
                # Continue without payment manager checks
        
        return {'valid': True, 'reason': None}
    
    def acquire_group_game_lock(self, chat_id, user_id, game_type):
        """Acquire a game lock for a group. Returns True if successful, False if someone else is playing."""
        with self.group_locks_lock:
            current_time = time.time()
            
            # Clean up expired locks (older than 5 minutes)
            if chat_id in self.group_game_locks:
                if current_time - self.group_game_locks[chat_id]['timestamp'] > 300:
                    del self.group_game_locks[chat_id]
            
            # Check if group is already locked by someone else
            if chat_id in self.group_game_locks:
                current_lock = self.group_game_locks[chat_id]
                if current_lock['user_id'] != user_id:
                    return False, current_lock
            
            # Acquire lock
            self.group_game_locks[chat_id] = {
                'user_id': user_id,
                'game_type': game_type,
                'timestamp': current_time
            }
            return True, None
    
    def release_group_game_lock(self, chat_id, user_id):
        """Release a game lock for a group"""
        with self.group_locks_lock:
            if chat_id in self.group_game_locks:
                if self.group_game_locks[chat_id]['user_id'] == user_id:
                    del self.group_game_locks[chat_id]
    
    def get_group_game_status(self, chat_id):
        """Get current game status for a group"""
        with self.group_locks_lock:
            if chat_id in self.group_game_locks:
                return self.group_game_locks[chat_id]
            return None
    
    def get_cached_or_fetch(self, key, fetch_func, ttl=60):
        """Get cached data or fetch and cache new data"""
        current_time = time.time()
        
        # Check if we have valid cached data
        if key in self.cache and key in self.cache_expiry:
            if current_time < self.cache_expiry[key]:
                return self.cache[key]
        
        # Fetch new data and cache it
        data = fetch_func()
        self.cache[key] = data
        self.cache_expiry[key] = current_time + ttl
        return data
    
    async def get_cached_or_fetch_async(self, key, fetch_func, ttl=60):
        """Get cached data or fetch and cache new data (async version)"""
        current_time = time.time()
        
        # Periodic cache cleanup to prevent memory bloat
        if current_time - self.last_cache_cleanup > 300:  # Every 5 minutes
            self.cleanup_expired_cache()
            self.last_cache_cleanup = current_time
        
        # Check if we have valid cached data
        if key in self.cache and key in self.cache_expiry:
            if current_time < self.cache_expiry[key]:
                return self.cache[key]
        
        # Fetch new data and cache it
        data = await fetch_func()
        self.cache[key] = data
        self.cache_expiry[key] = current_time + ttl
        return data
    
    def cleanup_expired_cache(self):
        """Clean up expired cache entries - optimized"""
        current_time = time.time()
        expired_keys = [k for k, expire_time in self.cache_expiry.items() if current_time > expire_time]
        for key in expired_keys:
            self.cache.pop(key, None)
            self.cache_expiry.pop(key, None)
        
        # Memory optimization: limit cache size
        if len(self.cache) > 1000:
            # Remove oldest 10% of entries
            sorted_keys = sorted(self.cache_expiry.keys(), key=lambda k: self.cache_expiry[k])[:100]
            for key in sorted_keys:
                self.cache.pop(key, None)
                self.cache_expiry.pop(key, None)
            # Force garbage collection after cleanup
            gc.collect()
        
        # Clean up telegram cache as well
        try:
            from safe_telegram_handler import cleanup_telegram_cache
            cleanup_telegram_cache()
        except ImportError:
            pass
            
        if expired_keys:
            logger.debug(f"Cleaned up {len(expired_keys)} expired cache entries")
    
    async def process_pending_payments(self):
        """Auto-process pending payments with error handling"""
        if not self.auto_payment_enabled or not self.crypto_handler:
            return
            
        # Rate limiting - only check every 30 seconds
        current_time = time.time()
        if current_time - self.last_payment_check < self.payment_check_interval:
            return
        
        self.last_payment_check = current_time
        
        try:
            with self.casino.db.get_connection() as conn:
                # Check pending deposits (only recent ones)
                pending_deposits = conn.execute(
                    '''SELECT * FROM deposits 
                       WHERE status = "pending" 
                       AND datetime(created_at, '+1 hour') > datetime('now')
                       LIMIT 20'''
                ).fetchall()
                
                logger.info(f"ğŸ” Checking {len(pending_deposits)} pending deposits")
                
                # Limit processing to prevent memory overload
                if len(pending_deposits) > 100:
                    pending_deposits = pending_deposits[:100]
                    logger.warning("Too many pending deposits, processing first 100 only")
                
                for deposit in pending_deposits:
                    # Memory check for pending transactions
                    if len(self.pending_transactions) >= self.max_pending_transactions:
                        # Remove oldest transactions
                        old_keys = list(self.pending_transactions.keys())[:100]
                        for key in old_keys:
                            self.pending_transactions.pop(key, None)
                    
                    try:
                        # Check payment status with CryptoBot
                        invoices = self.crypto_handler.get_invoices(
                            asset=deposit['currency'],
                            status='paid'
                        )
                        
                        if invoices.get('ok') and invoices.get('result'):
                            for invoice in invoices['result']:
                                if invoice['invoice_id'] == deposit['invoice_id']:
                                    await self.credit_user_deposit(deposit)
                                    logger.info(f"SUCCESS: Payment confirmed for user {deposit['user_id']}: {deposit['fun_coins']} ğŸ»")
                                    break
                    except Exception as e:
                        logger.error(f"Error checking deposit {deposit['id']}: {e}")
                        continue
                
                # Mark expired deposits
                expired_count = conn.execute(
                    '''UPDATE deposits SET status = 'expired' 
                       WHERE status = 'pending' AND 
                       datetime(created_at, '+1 hour') < datetime('now')'''
                ).rowcount
                
                if expired_count > 0:
                    logger.info(f"â° Marked {expired_count} deposits as expired")
                    conn.commit()
                
        except Exception as e:
            logger.error(f"Payment processing error: {e}")
    
    async def credit_user_deposit(self, deposit):
        """Credit user account after successful payment with bonuses"""
        try:
            with self.casino.db.get_connection() as conn:
                # Check if already processed
                current_status = conn.execute(
                    'SELECT status FROM deposits WHERE id = ?',
                    (deposit['id'],)
                ).fetchone()
                
                if current_status and current_status['status'] != 'pending':
                    return  # Already processed
                
                # Mark deposit as paid
                conn.execute(
                    'UPDATE deposits SET status = "paid", paid_at = CURRENT_TIMESTAMP WHERE id = ?',
                    (deposit['id'],)
                )
                
                # Calculate bonuses
                deposit_count = conn.execute(
                    'SELECT COUNT(*) FROM deposits WHERE user_id = ? AND status = "paid"',
                    (deposit['user_id'],)
                ).fetchone()[0]
                
                is_first_deposit = deposit_count == 1
                bonus_amount = 0
                
                # First deposit bonus
                if is_first_deposit:
                    bonus_amount += int(deposit['fun_coins'] * PAYMENT_SETTINGS.get('first_deposit_bonus', 0.2))
                
                # Weekend bonus
                is_weekend = datetime.now().weekday() >= 5
                if is_weekend:
                    weekend_bonus = int(deposit['fun_coins'] * 0.1)  # 10% weekend bonus
                    bonus_amount += weekend_bonus
                
                # VIP bonus
                vip_level = self.get_user_vip_level(deposit['user_id'])
                if vip_level > 0:
                    vip_bonus = int(deposit['fun_coins'] * (vip_level * 0.05))  # 5% per VIP level
                    bonus_amount += vip_bonus
                
                total_credit = deposit['fun_coins'] + bonus_amount
                
                # Credit user account
                conn.execute(
                    'UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?',
                    (total_credit, deposit['user_id'])
                )
                
                # Update daily limits
                today = datetime.now().date().isoformat()
                conn.execute(
                    '''INSERT OR REPLACE INTO daily_limits 
                       (user_id, date, deposited_amount) VALUES 
                       (?, ?, COALESCE((SELECT deposited_amount FROM daily_limits 
                                       WHERE user_id = ? AND date = ?), 0) + ?)''',
                    (deposit['user_id'], today, deposit['user_id'], today, deposit['fun_coins'])
                )
                
                # Award achievements
                if is_first_deposit:
                    self.casino.unlock_achievement(deposit['user_id'], "first_deposit")
                
                if deposit['fun_coins'] >= 50000:
                    self.casino.unlock_achievement(deposit['user_id'], "big_depositor")
                
                if deposit['fun_coins'] >= 500000:
                    self.casino.unlock_achievement(deposit['user_id'], "whale")
                
                conn.commit()
                
                logger.info(f"ğŸ» Credited {total_credit} ğŸ» to user {deposit['user_id']} (base: {deposit['fun_coins']}, bonus: {bonus_amount})")
                
        except Exception as e:
            logger.error(f"Error crediting deposit: {e}")
    
    def get_bet_suggestion(self, user_balance: int, vip_level: int) -> list:
        """Get suggested bet amounts based on user balance and VIP level"""
        max_bet = self.get_user_max_bet_by_vip(vip_level)
        
        # Calculate safe bet amounts
        suggestions = []
        
        # Conservative bets (1-5% of balance)
        suggestions.extend([
            int(user_balance * 0.01),  # 1%
            int(user_balance * 0.025), # 2.5%
            int(user_balance * 0.05),  # 5%
        ])
        
        # Medium bets (based on VIP level)
        if vip_level >= 1:
            suggestions.extend([
                int(user_balance * 0.1),   # 10%
                int(user_balance * 0.15),  # 15%
            ])
        
        if vip_level >= 3:
            suggestions.append(int(user_balance * 0.2))  # 20%
        
        # Filter valid bets
        valid_suggestions = []
        for bet in suggestions:
            if 5 <= bet <= min(max_bet, user_balance):
                valid_suggestions.append(bet)
        
        # Remove duplicates and sort
        return sorted(list(set(valid_suggestions)))[:6]  # Max 6 suggestions

    async def async_init_solana(self):
        """Initialize Solana system asynchronously after event loop is running"""
        if self._solana_initialized:
            return

        try:
            from solana_payment import get_solana_payment
            self.solana_system = get_solana_payment()
            if self.solana_system:
                await self.solana_system.ensure_initialized()
            logger.info("SUCCESS: Solana payment system initialized")
            self._solana_initialized = True
        except Exception as e:
            logger.error(f"WARNING: Solana system initialization failed: {e}")
            self.solana_system = None

# Global bot instance
bot = None

async def process_referral_bonus(casino, new_user_id, referral_code):
    """Process referral bonus for new users using new referral system"""
    try:
        result = casino.create_referral(referral_code, new_user_id)
        return result
    except Exception as e:
        logger.error(f"Referral bonus error: {e}")
        return {'success': False, 'error': str(e)}

# Bot handlers
async def check_group_membership(context_or_bot, user_id, chat_id=None):
    """Check if user is a member of the required group"""
    try:
        # Use the configured group username
        if not REQUIRED_GROUP_USERNAME:
            # If no group is configured, allow access
            return True
        
        # Try using group username first
        group_identifier = f"@{REQUIRED_GROUP_USERNAME}"
        
        # If a specific group ID is configured, use that instead
        if REQUIRED_GROUP_ID:
            group_identifier = REQUIRED_GROUP_ID
        
        # Get the bot from context or directly from the bot parameter
        bot_instance = None
        
        # More robust bot instance detection
        if hasattr(context_or_bot, 'bot') and context_or_bot.bot is not None:
            # This is a context object
            bot_instance = context_or_bot.bot
        elif hasattr(context_or_bot, 'application') and hasattr(context_or_bot.application, 'bot'):
            # This is an application object
            bot_instance = context_or_bot.application.bot
        elif hasattr(context_or_bot, 'get_chat_member') and 'Bot' in str(type(context_or_bot).__name__) and not hasattr(context_or_bot, 'first_name'):
            # This is already a bot instance - check by type name and ensure it's not a User object
            bot_instance = context_or_bot
        else:
            logger.error(f"Unable to extract bot instance. Object type: {type(context_or_bot)}, has bot: {hasattr(context_or_bot, 'bot')}, has get_chat_member: {hasattr(context_or_bot, 'get_chat_member')}, has first_name: {hasattr(context_or_bot, 'first_name')}")
            return False
            
        if bot_instance is None:
            logger.error("Bot instance is None after extraction")
            return False
            
        member = await bot_instance.get_chat_member(group_identifier, user_id)
        is_member = member.status in ['member', 'administrator', 'creator']
        
        logger.info(f"Group membership check for user {user_id}: {is_member} (status: {member.status})")
        return is_member
        
    except Exception as e:
        logger.error(f"Group membership check error for user {user_id}: {e}")
        # For new groups or if bot isn't admin, we can't check membership
        # In production, you might want to return False here to be more strict
        return False

async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Start command handler with error handling, referral system, and group requirement"""
    try:
        # Gruplarda /start komutuna yanÄ±t verme
        if update.effective_chat.type in ['group', 'supergroup']:
            return
            
        if bot is None:
            await update.message.reply_text(
                "âŒ Bot not initialized. Please restart the bot."
            )
            return
            
        bot.total_commands_processed += 1
        
        user_id = update.effective_user.id
        username = update.effective_user.username or "Anonim"
        
        
        # Check for referral code in start parameter
        referral_code = None
        if context.args and len(context.args) > 0:
            start_param = context.args[0]
            if start_param.startswith("friend_"):
                referral_code = start_param[7:]  # Remove "friend_" prefix
        
        # Get or create user
        user = bot.casino.get_user(user_id, username)

        # Process referral if this is a new user
        if referral_code and (user['games_count'] if 'games_count' in user else 0) == 0:  # New user
            referral_result = await process_referral_bonus(bot.casino, user_id, referral_code)
            if referral_result['success']:
                await update.message.reply_text(
                    f"ğŸ‰ **Referral Bonus!** ğŸ‰\n\n"
                    f"ğŸ» You received {referral_result['message']}\n"
                    f"ğŸ¤ Your referrer: {referral_result['referrer_name']}\n"
                    f"ğŸ“ˆ Now your referrer will earn 5% commission when you play!\n\n"
                    f"ğŸ® Welcome to the Casino!",
                    parse_mode='Markdown'
                )

        await show_main_menu(bot.casino, update, context, is_callback=False)
    except Exception as e:
        logger.error(f"Start command error: {e}")
        await update.message.reply_text(
            "ERROR: Bot failed to start. Please try again in a few seconds."
        )

async def handle_group_solo_game(query, user, casino, game_type, bet_amount, game_name):
    """Handle independent group games - NO LOCK SYSTEM - Everyone can play simultaneously"""
    try:
        # Import the new independent game handler
        try:
            from independent_group_game_handler import handle_independent_group_game
            
            # Redirect to the new independent handler
            await handle_independent_group_game(query, user, casino, game_type, bet_amount)
            return
        except ImportError:
            # Fall back to original implementation if the handler doesn't exist
            pass
        except Exception as e:
            # Log error and fall back to original implementation
            logger.error(f"Independent group game handler error: {e}")
            pass
        
        # Check if user has enough balance
        if user['fun_coins'] < bet_amount:
            await query.edit_message_text(
                f"ğŸ’¸ Yetersiz bakiye!\n\n"
                f"ğŸ’° Mevcut bakiye: {user['fun_coins']:,} ğŸ»\n"
                f"ğŸ¯ Gerekli miktar: {bet_amount:,} ğŸ»\n\n"
                f"ğŸ GÃ¼nlÃ¼k bonus alarak bakiye artÄ±rabilirsiniz!",
                reply_markup=casino.create_keyboard([
                    [("ğŸ GÃ¼nlÃ¼k Bonus", "daily_bonus")],
                    [("ğŸ”™ Geri", f"/game")]
                ]),
                parse_mode='Markdown'
            )
            return
        
        # Deduct bet amount
        casino.db.execute(
            "UPDATE users SET fun_coins = fun_coins - ? WHERE user_id = ?",
            (bet_amount, user['user_id'])
        )
        casino.db.commit()
        
        # Play the game using solo engine
        from solo_games import SoloGameEngine
        if not hasattr(casino, 'solo_engine'):
            casino.solo_engine = SoloGameEngine()
        
        # Play game based on type
        result = None
        if game_type == "solo_slots":
            result = casino.solo_engine.play_solo_slots(bet_amount, user['user_id'])
        elif game_type == "solo_roulette":
            result = casino.solo_engine.play_solo_roulette(bet_amount, "color", "red", user['user_id'])
        elif game_type == "solo_blackjack":
            result = casino.solo_engine.play_solo_blackjack(bet_amount, user['user_id'])
        elif game_type == "solo_baccarat":
            result = casino.solo_engine.play_solo_baccarat(bet_amount, "player", user['user_id'])
        elif game_type == "solo_crash":
            result = casino.solo_engine.play_solo_crash(bet_amount, 2.0, user['user_id'])
        elif game_type == "solo_mines":
            result = casino.solo_engine.play_solo_mines(bet_amount, 3, 3, user['user_id'])
        elif game_type == "solo_keno":
            result = casino.solo_engine.play_solo_keno(bet_amount, None, user['user_id'])
        elif game_type == "solo_dice":
            result = casino.solo_engine.play_solo_dice(bet_amount, 4, user['user_id'])
        elif game_type == "rock_paper_scissors":
            result = casino.solo_engine.play_rock_paper_scissors(bet_amount, None, user['user_id'])
        elif game_type == "number_guess":
            result = casino.solo_engine.play_number_guess(bet_amount, None, user['user_id'])
        elif game_type == "lucky_wheel":
            result = casino.solo_engine.play_lucky_wheel(bet_amount, user['user_id'])
        else:
            result = {'won': False, 'win_amount': 0, 'result_text': 'Oyun bulunamadÄ±!'}
        
        # Add winnings if won
        if result['won'] and result.get('win_amount', 0) > 0:
            casino.db.execute(
                "UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?",
                (result['win_amount'], user['user_id'])
            )
            casino.db.commit()
        
        # Update game statistics
        casino.db.execute(
            "UPDATE users SET games_count = games_count + 1 WHERE user_id = ?",
            (user['user_id'],)
        )
        
        # Record group game history for statistics
        try:
            chat_id = query.message.chat.id
            casino.db.execute("""
                INSERT OR IGNORE INTO game_history 
                (user_id, username, game_type, bet_amount, win_amount, won, chat_id, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))
            """, (
                user['user_id'], user['username'], game_type, bet_amount, 
                result.get('win_amount', 0), result['won'], chat_id
            ))
        except:
            # Create table if it doesn't exist
            casino.db.execute("""
                CREATE TABLE IF NOT EXISTS game_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    username TEXT,
                    game_type TEXT,
                    bet_amount INTEGER,
                    win_amount INTEGER,
                    won BOOLEAN,
                    chat_id INTEGER,
                    created_at DATETIME
                )
            """)
            casino.db.execute("""
                INSERT INTO game_history 
                (user_id, username, game_type, bet_amount, win_amount, won, chat_id, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))
            """, (
                user['user_id'], user['username'], game_type, bet_amount, 
                result.get('win_amount', 0), result['won'], chat_id
            ))
        
        # Create user_bonuses table if needed
        try:
            casino.db.execute("""
                CREATE TABLE IF NOT EXISTS user_bonuses (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    bonus_type TEXT,
                    amount INTEGER,
                    created_at DATETIME
                )
            """)
        except:
            pass
            
        casino.db.commit()
        
        # Get updated balance
        updated_user = casino.get_user(user['user_id'], user['username'])
        
        # Check for big wins and send live notifications
        win_amount = result.get('win_amount', 0)
        net_profit = win_amount - bet_amount
        
        # Optimized notification check - only for very big wins
        if result['won'] and (net_profit >= 2000 or win_amount >= 5000):
            # Send notification in background without blocking
            asyncio.create_task(send_big_win_notification(
                query.message.chat.id, user['username'], game_name, 
                win_amount, net_profit, result.get('special_effect', 'ğŸŠ MuhteÅŸem!')
            ))
        
        # Create result message
        if result['won']:
            result_text = f"""
ğŸ‰ **{game_name} - KAZANDIN!** ğŸ‰

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ’° **KazanÃ§:** {win_amount:,} ğŸ»
âœ¨ **Net Kar:** +{net_profit:,} ğŸ»

ğŸ’° **Yeni Bakiye:** {updated_user['fun_coins']:,} ğŸ»

{result.get('result_text', 'ğŸŠ Harika oyun!')}
{result.get('special_effect', '')}
            """
        else:
            result_text = f"""
ğŸ˜” **{game_name} - Kaybettin** ğŸ˜”

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ’¸ **KayÄ±p:** -{bet_amount:,} ğŸ»

ğŸ’° **Yeni Bakiye:** {updated_user['fun_coins']:,} ğŸ»

{result.get('result_text', 'ğŸ€ Bir dahaki sefere ÅŸansÄ±n olur!')}
            """
        
        # Create keyboard with URL button
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        keyboard_buttons = [
            [InlineKeyboardButton("ğŸ”„ Tekrar Oyna", callback_data=f"group_{game_type}_100"), 
             InlineKeyboardButton("ğŸ“Š Ä°statistikler", callback_data="group_stats")],
            [InlineKeyboardButton("ğŸ® DiÄŸer Oyunlar", callback_data="game_menu_return"), 
             InlineKeyboardButton("ğŸ’° GÃ¼nlÃ¼k Bonus", callback_data="daily_bonus")],
            [InlineKeyboardButton("ğŸ’¬ Bot ile Ã–zel Oyna", url=f"https://t.me/{query.get_bot().username}?start=fullgames")]
        ]
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        # Release group game lock
        bot.release_group_game_lock(chat_id, user_id)
        
        # Send private result message only to the player
        private_result_text = f"""
ğŸ¯ **Grup Oyunu Sonucu - Sadece Sen GÃ¶rÃ¼yorsun**

{result_text}

âš ï¸ DiÄŸer grup Ã¼yeleri sadece genel durumu gÃ¶rebilir.
ğŸ’¡ Ã–zel bilgilerin gizli kalmasÄ± iÃ§in bu mesaj sadece sana gÃ¶nderildi.
        """
        
        try:
            # Prepare messages
            public_summary = f"""
ğŸ® **Grup Oyunu TamamlandÄ±**

ğŸ‘¤ **Oyuncu:** @{user['username']}
ğŸ¯ **Oyun:** {game_name}
{'ğŸ‰ KazandÄ±!' if result['won'] else 'ğŸ˜” Kaybetti'}

ğŸ’¡ DetaylarÄ± Ã¶zel mesajda gÃ¶rebilirsin.
ğŸ® Sen de oynamak iÃ§in: /game
            """
            
            # Send both messages in parallel for speed
            private_task = asyncio.create_task(
                query.get_bot().send_message(
                    chat_id=user['user_id'], 
                    text=private_result_text, 
                    parse_mode='Markdown',
                    reply_markup=casino.create_keyboard([
                        [("ğŸ”„ Tekrar Oyna", f"group_{game_type}_{bet_amount}")],
                        [("ğŸ® TÃ¼m Oyunlar", "solo_games")]
                    ])
                )
            )
            
            public_task = asyncio.create_task(
                query.edit_message_text(
                    public_summary,
                    reply_markup=casino.create_keyboard([
                        [("ğŸ® Oyun Oyna", "games")],
                        [("ğŸ“Š Grup Ä°statistikleri", "group_stats")]
                    ]),
                    parse_mode='Markdown'
                )
            )
            
            # Wait for both to complete
            await asyncio.gather(private_task, public_task, return_exceptions=True)
            
        except Exception as pm_error:
            logger.error(f"Private message error: {pm_error}")
            # Fallback to group message if private message fails
            await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Group solo game error: {e}")
        # Release lock on error
        try:
            bot.release_group_game_lock(query.message.chat.id, user['user_id'])
        except:
            pass
        await query.edit_message_text(
            "âŒ Oyun oynanÄ±rken hata oluÅŸtu!\n"
            "ğŸ”„ LÃ¼tfen tekrar deneyin.",
            reply_markup=casino.create_keyboard([
                [("ğŸ”™ Geri", f"/game")]
            ])
        )

async def handle_group_dice_game(query, user, casino, dice_type, bet_amount, game_name):
    """Handle group dice games with Telegram dice API and group lock system"""
    try:
        chat_id = query.message.chat.id
        user_id = user['user_id']
        
        # Check if user has enough balance first
        if user['fun_coins'] < bet_amount:
            await query.edit_message_text(
                f"ğŸ’¸ **Yetersiz Bakiye!**\n\n"
                f"ğŸ’° Mevcut: {user['fun_coins']:,} ğŸ»\n"
                f"ğŸ¯ Gerekli: {bet_amount:,} ğŸ»\n\n"
                f"ğŸ GÃ¼nlÃ¼k bonus alarak bakiye artÄ±rabilirsin!",
                reply_markup=casino.create_keyboard([
                    [("ğŸ GÃ¼nlÃ¼k Bonus", "daily_bonus")],
                    [("ğŸ”™ Oyunlara DÃ¶n", "games")]
                ]),
                parse_mode='Markdown'
            )
            return
        
        # Deduct bet amount
        casino.db.execute(
            "UPDATE users SET fun_coins = fun_coins - ? WHERE user_id = ?",
            (bet_amount, user['user_id'])
        )
        casino.db.commit()
        
        # Import and use dice games
        from dice_games import get_dice_games_instance
        dice_games = get_dice_games_instance(casino)
        
        # Show pre-game animation
        dice_config = {
            'classic': {'emoji': 'ğŸ²', 'name': 'Klasik Zar', 'min': 1, 'max': 6},
            'darts': {'emoji': 'ğŸ¯', 'name': 'Dart', 'min': 1, 'max': 6},
            'basketball': {'emoji': 'ğŸ€', 'name': 'Basketbol', 'min': 1, 'max': 5},
            'football': {'emoji': 'âš½', 'name': 'Futbol', 'min': 1, 'max': 5},
            'bowling': {'emoji': 'ğŸ³', 'name': 'Bowling', 'min': 1, 'max': 6},
            'slot_machine': {'emoji': 'ğŸ°', 'name': 'Slot Dice', 'min': 1, 'max': 64}
        }
        
        config = dice_config.get(dice_type, dice_config['classic'])
        dice_emoji = config['emoji']
        dice_name = config['name']
        
        # Show animation
        await query.edit_message_text(
            f"{dice_emoji} **{dice_name}** {dice_emoji}\n\n"
            f"ğŸ» **Bahis:** {bet_amount:,} ğŸ»\n"
            f"ğŸ¯ **{dice_name} atÄ±lÄ±yor...**\n\n"
            f"â³ LÃ¼tfen bekleyin...",
            parse_mode='Markdown'
        )
        
        # Send actual Telegram dice
        import asyncio
        import random
        
        try:
            dice_message = await asyncio.wait_for(
                query.message.reply_dice(emoji=dice_emoji),
                timeout=10.0
            )
            dice_value = dice_message.dice.value
            
            # Wait for dice animation - UZATILDI
            await asyncio.sleep(6)

            # Delete dice message after animation
            try:
                await dice_message.delete()
            except:
                pass
                
        except:
            # Fallback to random value
            dice_value = random.randint(config['min'], config['max'])
        
        # Calculate payout based on dice type and value
        payout = 0
        result_text = ""
        
        if dice_type == 'classic':
            if dice_value == 6:
                payout = bet_amount * 6
                result_text = "ğŸ‰ **6 GELDÄ°!** JACKPOT! ğŸ‰"
            elif dice_value >= 4:
                payout = bet_amount * 2
                result_text = f"â­ **{dice_value}** - Ä°yi skor! â­"
            elif dice_value == 3:
                payout = bet_amount
                result_text = f"ğŸ˜Š **{dice_value}** - Ortalama skor"
            else:
                result_text = f"ğŸ’” **{dice_value}** - KÃ¶tÃ¼ ÅŸans"
                
        elif dice_type == 'darts':
            if dice_value == 6:
                payout = bet_amount * 10
                result_text = "ğŸ¯ **BULLSEYE!** PERFECT! ğŸ¯"
            elif dice_value >= 4:
                payout = bet_amount * 3
                result_text = f"â­ **{dice_value}** - Hedefe yakÄ±n! â­"
            elif dice_value >= 2:
                payout = bet_amount
                result_text = f"ğŸ˜Š **{dice_value}** - Hedefi vurdun!"
            else:
                result_text = f"ğŸ’” **{dice_value}** - TahtayÄ± kaÃ§Ä±rdÄ±n!"
                
        elif dice_type in ['basketball', 'football']:
            sport_name = "ğŸ€ BASKET" if dice_type == 'basketball' else "âš½ GOL"
            if dice_value >= 4:
                payout = bet_amount * 5
                result_text = f"{sport_name} OLDU! ğŸ‰"
            elif dice_value == 3:
                payout = bet_amount
                result_text = f"ğŸ˜Š **{dice_value}** - YaklaÅŸtÄ±n!"
            else:
                result_text = f"ğŸ’” **{dice_value}** - KaÃ§Ä±rdÄ±n!"
                
        elif dice_type == 'bowling':
            if dice_value == 6:
                payout = bet_amount * 6
                result_text = "ğŸ³ **STRIKE!** TÃ¼m pinler! ğŸ³"
            elif dice_value >= 4:
                payout = bet_amount * 2
                result_text = f"â­ **{dice_value}** - Ã‡ok pin!"
            elif dice_value == 3:
                payout = bet_amount
                result_text = f"ğŸ˜Š **{dice_value}** - BazÄ± pin"
            else:
                result_text = f"ğŸ’” **{dice_value}** - Gutter ball!"
                
        elif dice_type == 'slot_machine':
            if dice_value == 64:
                payout = bet_amount * 100
                result_text = "ğŸ° **MEGA JACKPOT!** ÃœÃ§lÃ¼ 7! ğŸ’"
            elif dice_value in [1, 22, 43]:
                payout = bet_amount * 50
                result_text = f"ğŸ”¥ **Ã–ZEL JACKPOT #{dice_value}!** ğŸ”¥"
            elif dice_value >= 50:
                payout = bet_amount * 10
                result_text = f"â­ **YÃ¼ksek Kombinasyon #{dice_value}** â­"
            elif dice_value >= 30:
                payout = bet_amount * 5
                result_text = f"ğŸ˜Š **Orta Kombinasyon #{dice_value}**"
            elif dice_value >= 15:
                payout = bet_amount * 2
                result_text = f"ğŸ€ **KÃ¼Ã§Ã¼k Kombinasyon #{dice_value}**"
            else:
                result_text = f"ğŸ’” **Kombinasyon #{dice_value}** - Kaybettin!"
        
        # Add winnings
        if payout > 0:
            casino.db.execute(
                "UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?",
                (payout, user['user_id'])
            )
            casino.db.commit()
        
        # Update stats
        casino.db.execute(
            "UPDATE users SET games_count = games_count + 1 WHERE user_id = ?",
            (user['user_id'],)
        )
        
        # Record game history
        try:
            chat_id = query.message.chat.id
            casino.db.execute("""
                INSERT OR IGNORE INTO game_history 
                (user_id, username, game_type, bet_amount, win_amount, won, chat_id, created_at) 
                VALUES (?, ?, ?, ?, ?, ?, ?, datetime('now'))
            """, (
                user['user_id'], user['username'], f"dice_{dice_type}", bet_amount, 
                payout, payout > 0, chat_id
            ))
            casino.db.commit()
        except:
            pass
        
        # Get updated user
        updated_user = casino.get_user(user['user_id'], user['username'])
        net_profit = payout - bet_amount
        
        # Create result message
        if payout > 0:
            final_text = f"""
ğŸ‰ **{game_name} - KAZANDIN!** ğŸ‰

{dice_emoji} **SonuÃ§:** {dice_value}
{result_text}

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ’° **KazanÃ§:** {payout:,} ğŸ»
âœ¨ **Net Kar:** +{net_profit:,} ğŸ»

ğŸ’° **Yeni Bakiye:** {updated_user['fun_coins']:,} ğŸ»
            """
        else:
            final_text = f"""
ğŸ˜” **{game_name} - Kaybettin** ğŸ˜”

{dice_emoji} **SonuÃ§:** {dice_value}
{result_text}

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ’¸ **KayÄ±p:** -{bet_amount:,} ğŸ»

ğŸ’° **Yeni Bakiye:** {updated_user['fun_coins']:,} ğŸ»

ğŸ€ Bir dahaki sefere ÅŸansÄ±n olur!
            """
        
        # Create keyboard with URL button
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        keyboard_buttons = [
            [InlineKeyboardButton("ğŸ”„ Tekrar Oyna", callback_data=f"group_dice_{dice_type}_100"), 
             InlineKeyboardButton("ğŸ“Š Ä°statistikler", callback_data="group_stats")],
            [InlineKeyboardButton("ğŸ® DiÄŸer Oyunlar", callback_data="game_menu_return"), 
             InlineKeyboardButton("ğŸ’° GÃ¼nlÃ¼k Bonus", callback_data="daily_bonus")],
            [InlineKeyboardButton("ğŸ’¬ Bot ile Ã–zel Oyna", url=f"https://t.me/{query.get_bot().username}?start=fullgames")]
        ]
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        # Release group game lock
        bot.release_group_game_lock(chat_id, user_id)
        
        # Send private result to player and public summary to group (similar to solo games)
        private_result = f"""
ğŸ¯ **Zar Oyunu Sonucu - Sadece Sen GÃ¶rÃ¼yorsun**

{final_text}

âš ï¸ DiÄŸer grup Ã¼yeleri sadece genel durumu gÃ¶rebilir.
ğŸ’¡ Ã–zel bilgilerin gizli kalmasÄ± iÃ§in bu mesaj sadece sana gÃ¶nderildi.
        """
        
        try:
            # Prepare messages
            public_summary = f"""
ğŸ® **Grup Zar Oyunu TamamlandÄ±**

ğŸ‘¤ **Oyuncu:** @{user['username']}  
ğŸ¯ **Oyun:** {game_name}
ğŸ² **SonuÃ§:** {result['dice_value']}
{'ğŸ‰ KazandÄ±!' if result['won'] else 'ğŸ˜” Kaybetti'}

ğŸ’¡ DetaylarÄ± Ã¶zel mesajda gÃ¶rebilirsin.
ğŸ® Sen de oynamak iÃ§in: /game
            """
            
            # Send both messages in parallel for speed
            private_task = asyncio.create_task(
                query.get_bot().send_message(
                    chat_id=user['user_id'], 
                    text=private_result, 
                    parse_mode='Markdown',
                    reply_markup=casino.create_keyboard([
                        [("ğŸ”„ Tekrar Oyna", f"group_dice_{dice_type}_{bet_amount}")],
                        [("ğŸ® TÃ¼m Oyunlar", "games")]
                    ])
                )
            )
            
            public_task = asyncio.create_task(
                query.edit_message_text(
                    public_summary,
                    reply_markup=casino.create_keyboard([
                        [("ğŸ® Oyun Oyna", "games")],
                        [("ğŸ“Š Grup Ä°statistikleri", "group_stats")]
                    ]),
                    parse_mode='Markdown'
                )
            )
            
            # Wait for both to complete
            await asyncio.gather(private_task, public_task, return_exceptions=True)
            
        except Exception as pm_error:
            logger.error(f"Private message error: {pm_error}")
            # Fallback to group message if private message fails
            await query.edit_message_text(final_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Group dice game error: {e}")
        # Release lock on error
        try:
            bot.release_group_game_lock(query.message.chat.id, user['user_id'])
        except:
            pass
        await query.edit_message_text(
            "âŒ Dice oyunu sÄ±rasÄ±nda hata oluÅŸtu!\n"
            "ğŸ”„ LÃ¼tfen tekrar deneyin.",
            reply_markup=casino.create_keyboard([
                [("ğŸ”™ Geri", "game_menu_return")]
            ])
        )

async def send_big_win_notification(chat_id, username, game_name, win_amount, net_profit, special_effect):
    """Send big win notification in background - OPTIMIZED"""
    try:
        notification_text = f"""
ğŸ”¥ **BÃœYÃœK KAZANÃ‡!** ğŸ”¥

ğŸ‘¤ **{username}** oynadÄ± **{game_name}**
ğŸ’° **KazanÃ§:** {win_amount:,} ğŸ»
âœ¨ **Net Kar:** +{net_profit:,} ğŸ»

{special_effect}

ğŸ® Sen de ÅŸansÄ±nÄ± dene: /game
        """
        
        await bot.application.bot.send_message(
            chat_id=chat_id,
            text=notification_text,
            parse_mode='Markdown'
        )
    except Exception as e:
        logger.error(f"Big win notification error: {e}")

async def safe_query_answer(query, text="", show_alert=False):
    """Safely answer a callback query, handling expired queries - ENHANCED"""
    try:
        from safe_telegram_handler import safe_answer_query
        return await safe_answer_query(query, text, show_alert)
    except ImportError:
        # Fallback to original implementation
        try:
            await query.answer(text, show_alert=show_alert)
            return True
        except Exception as e:
            err_str = str(e)
            if "too old" in err_str or "timeout" in err_str or "invalid" in err_str:
                return False
            logger.error(f"Callback query error: {e}")
            return False

async def safe_query_edit(query, text, reply_markup=None, parse_mode=None):
    """Safely edit a callback query message, handling expired queries - ENHANCED"""
    try:
        from safe_telegram_handler import safe_edit_message
        return await safe_edit_message(query, text, reply_markup, parse_mode)
    except ImportError:
        # Fallback to original implementation
        try:
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
            return True
        except Exception as e:
            err_str = str(e).lower()
            if "query is too old" in err_str or "response timeout expired" in err_str or "query id is invalid" in err_str:
                logger.debug(f"Callback query expired, ignoring edit: {e}")
                return False
            elif "message is not modified" in err_str:
                logger.debug("Message content unchanged, ignoring")
                return True
            else:
                logger.error(f"Error editing callback query: {e}")
                return False

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle all callback queries with enhanced error handling"""
    query = update.callback_query
    
    # Handle expired queries gracefully
    if not await safe_query_answer(query):
        return  # Query expired or failed


    

    try:
        # Check if bot is initialized
        if bot is None:
            await safe_query_edit(query, "âŒ Bot not initialized. Please restart the bot.")
            return
            
        bot.total_commands_processed += 1
        data = query.data
        
        # Quick answer for immediate feedback - use safe handler
        await safe_query_answer(query)
        
        # Get user data only when needed (not for all callbacks)
        user = None
        if data not in ["main_menu", "game_menu_return"]:  # Skip user data for simple navigation
            user = bot.casino.get_user(query.from_user.id, query.from_user.username)
        
        # Group membership check removed - direct access to all features
        
        # Main menu
        if data == "main_menu":
            await show_main_menu(bot.casino, query, context, is_callback=True)
        elif data == "game_menu_return":
            # Return to group game menu
            if hasattr(query.message, 'chat') and query.message.chat.type in ['group', 'supergroup']:
                # Show simple return message
                await query.edit_message_text(
                    "ğŸ® **Oyunlara geri dÃ¶nÃ¼yorsunuz...**\n\n"
                    "âœ¨ Oyuna devam etmek iÃ§in `/game` yazÄ±n!\n"
                    "ğŸ¯ TÃ¼m oyunlar 100ğŸ» sabit bahisle oynanÄ±r.",
                    reply_markup=None,
                    parse_mode='Markdown'
                )
            else:
                await show_main_menu(bot.casino, query, context, is_callback=True)
            return
        
        # Language selection
        elif data == "language_selection":
            from language_handler import show_language_selection
            await show_language_selection(query, user, bot.casino)
        elif data == "check_membership":
            # Redirect directly to main menu since group membership is no longer required
            await show_main_menu(bot.casino, query, None, is_callback=True)
        elif data == "join_group":
            # Direct link to Telegram group
            from languages import get_text, DEFAULT_LANGUAGE
            username = query.from_user.username or "Player"
            user_id = query.from_user.id

            # Get user language
            user_lang = DEFAULT_LANGUAGE
            if hasattr(bot.casino.db, 'get_user_language'):
                try:
                    user_lang = bot.casino.db.get_user_language(user_id)
                except:
                    user_lang = DEFAULT_LANGUAGE

            group_title = get_text(user_lang, "group.our_telegram_group", "ğŸ‰ <b>Our Telegram Group!</b> ğŸ‰")
            hello_text = get_text(user_lang, "group.hello", "Hello {username}! ğŸ‘‹", username=username)
            official_group = get_text(user_lang, "group.official_group", "ğŸ® <b>Our Official Telegram Group:</b> @{group_name}", group_name=REQUIRED_GROUP_USERNAME)
            whats_in_group = get_text(user_lang, "group.whats_in_group", "ğŸ“‹ <b>What's in the group?</b>")
            daily_bonuses = get_text(user_lang, "group.daily_bonuses", "â€¢ ğŸ‰ Daily bonuses and giveaways")
            bot_updates = get_text(user_lang, "group.bot_updates", "â€¢ ğŸ“¢ Bot updates and announcements")
            chat_players = get_text(user_lang, "group.chat_players", "â€¢ ğŸ‘¥ Chat with other players")
            tournament_notifications = get_text(user_lang, "group.tournament_notifications", "â€¢ ğŸ¯ Tournament notifications")
            help_support = get_text(user_lang, "group.help_support", "â€¢ ğŸ†˜ Help and support")
            join_fun = get_text(user_lang, "group.join_fun", "ğŸš€ Join now and have more fun at the casino!")
            join_group_btn = get_text(user_lang, "group.join_group", "ğŸ‘¥ Join Group")
            back_main_btn = get_text(user_lang, "group.back_main_menu", "ğŸ  Back to Main Menu")

            await query.edit_message_text(
                f"{group_title}\n\n"
                f"{hello_text}\n\n"
                f"{official_group}\n\n"
                f"{whats_in_group}\n"
                f"{daily_bonuses}\n"
                f"{bot_updates}\n"
                f"{chat_players}\n"
                f"{tournament_notifications}\n"
                f"{help_support}\n\n"
                f"{join_fun}",
                reply_markup=bot.casino.create_keyboard([
                    [(join_group_btn, REQUIRED_GROUP_URL)],
                    [(back_main_btn, "main_menu")]
                ]),
                parse_mode='HTML'
            )
        elif data.startswith("set_language_"):
            language_code = data.split("_", 2)[2]
            from language_handler import handle_set_language
            await handle_set_language(query, user, language_code, bot.casino)
        
        # Payment system
        elif data == "payment_menu":
            if bot.payment_manager and PAYMENT_HANDLERS_AVAILABLE:
                await show_payment_menu(query, user, bot.casino)
            else:
                # Simple payment menu fallback
                await show_simple_payment_menu(query, user, bot.casino)

        elif data == "cryptobot_menu":
            await show_cryptobot_payment_menu(query, user, bot.casino)

        elif data == "deposit_menu" and bot.payment_manager:
            from payment_handlers import show_deposit_menu
            await show_deposit_menu(query, user, bot.casino)
        elif data == "withdraw_menu" and bot.payment_manager:
            from payment_handlers import show_withdraw_menu
            await show_withdraw_menu(query, user, bot.casino)
        elif data.startswith("select_deposit_") and bot.payment_manager:
            # Redirect directly to Solana deposit menu
            from payment_handlers import show_solana_deposit_menu
            await show_solana_deposit_menu(query, user, bot.casino)
        elif data.startswith("select_amount_") and bot.payment_manager:
            parts = data.split("_")
            crypto, amount = parts[2], parts[3]
            from payment_handlers import handle_amount_selection
            await handle_amount_selection(query, user, crypto, amount, bot.casino)
        elif data.startswith("confirm_deposit_") and bot.payment_manager:
            parts = data.split("_")
            if len(parts) >= 5:  # Has wallet info
                crypto, amount, wallet = parts[2], parts[3], parts[4]
                from payment_handlers import handle_confirm_deposit
                await handle_confirm_deposit(query, user, crypto, amount, wallet, bot.casino)
            else:  # Old format without wallet
                crypto, amount = parts[2], parts[3]
                from payment_handlers import handle_confirm_deposit
                await handle_confirm_deposit(query, user, crypto, amount, None, bot.casino)
        elif data.startswith("select_withdraw_") and bot.payment_manager:
            crypto = data.split("_", 2)[2]
            from payment_handlers import handle_withdraw_crypto_selection
            await handle_withdraw_crypto_selection(query, user, crypto, bot.casino)
        elif data.startswith("confirm_withdraw_") and bot.payment_manager:
            parts = data.split("_")
            crypto, amount = parts[2], parts[3]
            from payment_handlers import handle_confirm_withdraw
            await handle_confirm_withdraw(query, user, crypto, amount, bot.casino)
        elif data == "payment_history" and bot.payment_manager:
            from payment_handlers import show_payment_history
            await show_payment_history(query, user, bot.casino)
        elif data == "vip_info":
            from payment_handlers import show_vip_info
            await show_vip_info(query, user, bot.casino)
        elif data == "crypto_rates" and bot.payment_manager:
            from payment_handlers import show_crypto_rates
            await show_crypto_rates(query, bot.casino)
        elif data == "limits_info":
            from payment_handlers import show_limits_info
            await show_limits_info(query, user, bot.casino)
        elif data == "bonus_info":
            from payment_handlers import show_bonus_info
            await show_bonus_info(query, user, bot.casino)
        
        # Solana Payment Handlers (New Flow)
        elif data == "solana_deposit_direct":
            from payment_handlers import show_solana_deposit_direct
            await show_solana_deposit_direct(query, user, bot.casino)
        elif data == "solana_deposit_menu":
            from payment_handlers import show_solana_deposit_menu
            await show_solana_deposit_menu(query, user, bot.casino)
        elif data == "solana_withdraw_menu":
            from payment_handlers import show_solana_withdraw_menu
            await show_solana_withdraw_menu(query, user, bot.casino)
        elif data == "solana_rates":
            from payment_handlers import show_solana_rates
            await show_solana_rates(query, bot.casino)
        elif data.startswith("deposit_wallet_"):
            parts = data.split("_")
            wallet_id = parts[2]
            sol_amount = parts[3]
            from payment_handlers import handle_deposit_wallet_selected
            await handle_deposit_wallet_selected(query, user, wallet_id, sol_amount, bot.casino)
        elif data.startswith("deposit_wallet_direct_"):
            wallet_id = data.split("_")[3]
            from payment_handlers import handle_deposit_wallet_direct
            await handle_deposit_wallet_direct(query, user, wallet_id, bot.casino)
        elif data.startswith("notify_admin_deposit_"):
            wallet_id = data.split("_")[3]
            from payment_handlers import handle_notify_admin_deposit
            await handle_notify_admin_deposit(query, user, wallet_id, bot.casino)

        # Legacy Solana Payment Handlers (Keep for compatibility)
        elif data == "solana_payment":
            await show_solana_payment_menu(query, user, bot.casino)
        elif data == "solana_deposit":
            await show_solana_deposit_menu(query, user, bot.casino)
        elif data == "deposit_sol_custom":
            from solana_handlers import show_custom_sol_amount_input
            # Set waiting flag for custom amount input
            context.user_data['waiting_for_custom_sol_amount'] = True
            await show_custom_sol_amount_input(query, user, bot.casino)
        elif data.startswith("deposit_sol_"):
            sol_amount = data.split("_")[2]
            await handle_solana_deposit(query, user, sol_amount, bot.casino)
        elif data.startswith("select_sol_amount_"):
            sol_amount = data.split("_")[-1]
            from solana_handlers import show_sol_amount_confirmation
            await show_sol_amount_confirmation(query, user, sol_amount, bot.casino)
        elif data.startswith("wallet_"):
            # Handle wallet selection (e.g., wallet_phantom_0.5)
            parts = data.split("_")
            wallet_type = parts[1]
            sol_amount = parts[2]
            await handle_wallet_selection(query, user, wallet_type, sol_amount, bot.casino)
        elif data == "solana_withdraw":
            await show_solana_withdraw_menu(query, user, bot.casino)
        elif data == "withdraw_sol_custom":
            from solana_handlers import show_custom_withdrawal_amount_input
            # Set waiting flag for custom withdrawal amount input
            context.user_data['waiting_for_custom_withdrawal_amount'] = True
            await show_custom_withdrawal_amount_input(query, user, bot.casino)
        elif data.startswith("withdraw_sol_"):
            sol_amount = data.split("_")[2]
            await show_withdrawal_wallet_input(query, user, sol_amount, bot.casino)
        elif data == "solana_help":
            await show_solana_help(query, user, bot.casino)
        
        # Solana Admin Handlers
        elif data == "solana_admin":
            await show_solana_admin_panel(query, user, bot.casino)
        elif data == "solana_pending_withdrawals":
            await show_pending_withdrawals(query, user, bot.casino)
        elif data.startswith("approve_withdrawal_"):
            withdrawal_id = data.split("_")[2]
            await approve_withdrawal(query, user, withdrawal_id, bot.casino)
        elif data.startswith("reject_withdrawal_"):
            withdrawal_id = data.split("_")[2]
            await reject_withdrawal(query, user, withdrawal_id, bot.casino)
        elif data == "solana_update_rate":
            await show_solana_rate_update(query, user, bot.casino)
        elif data.startswith("update_rate_"):
            new_rate = data.split("_")[2]
            await update_solana_rate(query, user, new_rate, bot.casino)
        elif data == "solana_stats":
            await show_solana_stats(query, user, bot.casino)
        elif data.startswith("check_deposit_"):
            # Check Solana deposit status
            deposit_id = data.split("_")[2]
            await check_solana_deposit_status(query, user, deposit_id, bot.casino)
        elif data.startswith("check_withdrawal_"):
            # Check Solana withdrawal status  
            withdrawal_id = data.split("_")[2]
            await check_solana_withdrawal_status(query, user, withdrawal_id, bot.casino)
        elif data.startswith("wallet_stats_"):
            # Show user wallet statistics
            await show_user_wallet_stats(query, user, bot.casino)

        # Wallet selection system
        elif data == "wallet_selection":
            from wallet_selector import show_wallet_selection_menu
            await show_wallet_selection_menu(query, context)
        elif data.startswith("select_wallet_"):
            from wallet_selector import handle_wallet_selection
            await handle_wallet_selection(query, context)
        elif data.startswith("open_wallet_mobile_"):
            from wallet_selector import handle_wallet_mobile_open
            await handle_wallet_mobile_open(query, context)
        elif data.startswith("wallet_deposit_"):
            from wallet_selector import handle_wallet_deposit_amount
            await handle_wallet_deposit_amount(query, context)
        elif data.startswith("confirm_wallet_payment_"):
            from wallet_selector import handle_wallet_payment_confirmation
            await handle_wallet_payment_confirmation(query, context, user, bot.casino)

        # Admin Ã¶deme onay sistemi
        elif data.startswith("admin_approve_deposit_"):
            if is_admin_user(query.from_user.id):
                from wallet_selector import handle_admin_approve_deposit
                await handle_admin_approve_deposit(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)
        elif data.startswith("admin_reject_deposit_"):
            if is_admin_user(query.from_user.id):
                from wallet_selector import handle_admin_reject_deposit
                await handle_admin_reject_deposit(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)
        elif data.startswith("admin_deposit_details_"):
            if is_admin_user(query.from_user.id):
                from wallet_selector import show_admin_deposit_details
                await show_admin_deposit_details(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)

        # Admin Ã§ekim onay sistemi
        elif data.startswith("admin_approve_withdrawal_"):
            if is_admin_user(query.from_user.id):
                from withdrawal_handlers import handle_admin_approve_withdrawal
                await handle_admin_approve_withdrawal(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)
        elif data.startswith("admin_reject_withdrawal_"):
            if is_admin_user(query.from_user.id):
                from withdrawal_handlers import handle_admin_reject_withdrawal
                await handle_admin_reject_withdrawal(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)
        elif data.startswith("admin_withdrawal_details_"):
            if is_admin_user(query.from_user.id):
                from withdrawal_handlers import show_admin_withdrawal_details
                await show_admin_withdrawal_details(query, context, bot.casino)
            else:
                await query.answer("âŒ Admin yetkisi gerekli!", show_alert=True)

        # Solana deposit amount selection - show wallet selection
        elif data.startswith("select_deposit_amount_"):
            sol_amount = data.replace("select_deposit_amount_", "")
            from solana_wallet_flow import show_deposit_wallet_selection
            await show_deposit_wallet_selection(query, context, sol_amount)

        # Solana withdrawal amount selection - wallet seÃ§imi iÃ§in
        elif data.startswith("select_withdrawal_amount_"):
            sol_amount = data.replace("select_withdrawal_amount_", "")
            from solana_wallet_flow import show_withdrawal_wallet_selection
            await show_withdrawal_wallet_selection(query, context, sol_amount)

        # Deposit wallet selection
        elif data.startswith("deposit_select_wallet_"):
            parts = data.replace("deposit_select_wallet_", "").split("_")
            wallet_id = parts[0]
            sol_amount = parts[1]
            from solana_wallet_flow import handle_deposit_wallet_selection
            await handle_deposit_wallet_selection(query, context, wallet_id, sol_amount)

        # Withdrawal wallet selection
        elif data.startswith("withdrawal_select_wallet_"):
            parts = data.replace("withdrawal_select_wallet_", "").split("_")
            wallet_id = parts[0]
            sol_amount = parts[1]
            from solana_wallet_flow import handle_withdrawal_wallet_selection
            await handle_withdrawal_wallet_selection(query, context, wallet_id, sol_amount)

        # Automatic deposit detection
        elif data.startswith("start_auto_detection_"):
            sol_amount = data.replace("start_auto_detection_", "")
            from solana_flow_completion import start_automatic_deposit_detection
            await start_automatic_deposit_detection(query, context, user, bot.casino, sol_amount)

        # Check balance
        elif data == "check_balance":
            from payment_handlers import show_balance_info
            await show_balance_info(query, user, bot.casino)

        # Legacy: Deposit confirmation after wallet selection (keep for compatibility)
        elif data.startswith("confirm_deposit_sent_"):
            sol_amount = data.replace("confirm_deposit_sent_", "")
            # Redirect to automatic detection
            from solana_flow_completion import start_automatic_deposit_detection
            await start_automatic_deposit_detection(query, context, user, bot.casino, sol_amount)

        # Wallet address input for withdrawal
        elif data.startswith("input_wallet_address_"):
            sol_amount = data.replace("input_wallet_address_", "")
            from solana_flow_completion import show_wallet_address_input
            await show_wallet_address_input(query, context, sol_amount)
        
        # Enhanced CryptoBot deposit handlers
        elif data.startswith("deposit_") and len(data.split("_")) == 2:
            # Deposit crypto selection (e.g., deposit_usdt, deposit_ton)
            crypto = data.split("_")[1].upper()
            from payment_handlers import process_deposit_request
            await process_deposit_request(query, user, crypto, bot.casino)
        elif data.startswith("deposit_") and len(data.split("_")) >= 3:
            # Specific deposit amount selection (e.g., deposit_usdt_5)
            parts = data.split("_")
            crypto = parts[1].upper()
            try:
                amount = float(parts[2])
                from payment_handlers import handle_confirm_deposit
                await handle_confirm_deposit(query, user, crypto, amount, bot.casino)
            except (ValueError, IndexError):
                from payment_handlers import show_deposit_menu
                await show_deposit_menu(query, user, bot.casino)
        
        # Enhanced CryptoBot withdrawal handlers  
        elif data.startswith("withdraw_") and len(data.split("_")) == 2:
            # Withdraw crypto selection (e.g., withdraw_usdt, withdraw_ton)
            crypto = data.split("_")[1].upper()
            from payment_handlers import process_withdrawal_request
            await process_withdrawal_request(query, user, crypto, bot.casino)
        elif data.startswith("withdraw_") and len(data.split("_")) >= 3:
            # Specific withdrawal amount selection (e.g., withdraw_usdt_10)
            parts = data.split("_")
            crypto = parts[1].upper()
            try:
                if parts[2] == "all":
                    # Handle withdraw all balance
                    if hasattr(bot, 'payment_manager') and bot.payment_manager:
                        try:
                            user_balance = await bot.payment_manager._get_user_balance(user['user_id'], crypto)
                            amount = user_balance
                        except:
                            amount = 0
                    else:
                        amount = 0
                else:
                    amount = float(parts[2])
                from payment_handlers import handle_confirm_withdraw
                await handle_confirm_withdraw(query, user, crypto, amount, bot.casino)
            except (ValueError, IndexError):
                from payment_handlers import show_withdrawal_menu
                await show_withdrawal_menu(query, user, bot.casino)
        
        # Enhanced solo games with better functionality
        elif data == "solo_games":
            await show_enhanced_solo_games_menu(query, user, bot.casino, bot)
        elif data == "games":
            # Handle games callback - redirect to group game menu
            if hasattr(query.message, 'chat') and query.message.chat.type in ['group', 'supergroup']:
                # For group chats, recreate the group game menu
                # Get the user and chat information
                user_id = query.from_user.id
                username = query.from_user.username or "Anonymous"
                user = bot.casino.get_user(user_id, username)
                chat_id = query.message.chat.id
                
                # Get cached group data for performance
                group_members = await bot.get_cached_or_fetch_async(
                    f"group_members_{chat_id}", 
                    lambda: get_group_member_count(context.bot, chat_id), 
                    ttl=300  # 5 minutes cache for member count
                )
                group_bonus = calculate_group_bonus(group_members)
                
                # Get group statistics with short cache
                group_stats = await bot.get_cached_or_fetch_async(
                    f"group_stats_{chat_id}",
                    lambda: get_group_stats(context.bot, chat_id, bot.casino),
                    ttl=30  # 30 seconds cache for stats
                )
                
                # Create the same menu as in game_command function
                games_text = f"""
ğŸ® **GRUP SOLO OYUN MENÃœSÃœ** ğŸ®

ğŸ‘‹ Hello {username}! Welcome to group solo gaming!

ğŸ“Š **GROUP STATISTICS (Today):**
ğŸ¯ **Games Played:** {group_stats['games_today']} games
ğŸ’° **Total Winnings:** {group_stats['winnings_today']:,} ğŸ»
ğŸ‘‘ **Most Active:** {group_stats['top_player']} ({group_stats['top_player_games']} games)
ğŸ‘¥ **Member Count:** {group_members} members

ğŸ¯ **Classic Casino Games (4 games):**
â€¢ ğŸ° **Slot Machine** - 3 reel luck!
â€¢ ğŸ”´ **Roulette** - Red or black?
â€¢ â™ ï¸ **Blackjack** - 21'e yaklaÅŸ!
â€¢ ğŸƒ **Baccarat** - Banker vs Player!

ğŸš€ **Modern Oyunlar (3 oyun):**
â€¢ ğŸš€ **Crash** - Roket kaÃ§madan Ã§Ä±k!
â€¢ â›ï¸ **Mines** - MayÄ±nlarÄ± sakÄ±n!
â€¢ ğŸ¯ **Keno** - SayÄ±larÄ± tahmin et!

ğŸ² **Telegram Dice OyunlarÄ± (6 oyun):**
â€¢ ğŸ² **Klasik Zar** - 1-6 arasÄ± gerÃ§ek zar!
â€¢ ğŸ¯ **Dart** - Bullseye vur! (x10)
â€¢ ğŸ€ **Basketbol** - Basket at! (x5)
â€¢ âš½ **Futbol** - Gol vur! (x5)
â€¢ ğŸ³ **Bowling** - Strike! (x6)
â€¢ ğŸ° **Dice Slot** - 64 kombinasyon!

ğŸª **EÄŸlence OyunlarÄ± (4 oyun):**
â€¢ ğŸª **Lucky Wheel** - Åans Ã§arkÄ±!
â€¢ ğŸ² **Solo Zar** - Basit zar oyunu!
â€¢ âœ‚ï¸ **TaÅŸ-KaÄŸÄ±t-Makas** - Klasik!
â€¢ ğŸ”¢ **SayÄ± Tahmin** - 1-100 arasÄ±!

ğŸ’° **Bakiyeniz:** {user['fun_coins']:,} ğŸ»
ğŸ® **Oyun SayÄ±nÄ±z:** {user['games_count'] if 'games_count' in user.keys() else 0}

âš ï¸ **NOT:** TÃ¼m oyunlar 100ğŸ» sabit bahisle oynanÄ±r.
ğŸ”¥ **Big wins are announced to the group!**
                """
                
                # Create complete game selection keyboard for groups - 6 GAMES
                from telegram import InlineKeyboardButton, InlineKeyboardMarkup
                
                keyboard_buttons = [
                    # Telegram Dice Games (6 games)
                    [InlineKeyboardButton("ğŸ° Dice Slot (100ğŸ»)", callback_data="group_dice_slot_100"),
                     InlineKeyboardButton("âš½ Futbol (100ğŸ»)", callback_data="group_dice_football_100")],
                    [InlineKeyboardButton("ğŸ³ Bowling (100ğŸ»)", callback_data="group_dice_bowling_100")],
                    [InlineKeyboardButton("ğŸ² Klasik Zar (100ğŸ»)", callback_data="group_dice_classic_100"),
                     InlineKeyboardButton("ğŸ¯ Dart (100ğŸ»)", callback_data="group_dice_darts_100")],
                    [InlineKeyboardButton("ğŸ€ Basketbol (100ğŸ»)", callback_data="group_dice_basketball_100")],
                    # Menu Options - NO MAIN MENU BUTTON
                    [InlineKeyboardButton("â³ Oyun Durumu", callback_data="group_game_status"),
                     InlineKeyboardButton("ğŸ“Š Grup Ä°statistikleri", callback_data="group_stats")],
                    [InlineKeyboardButton("ğŸ‘¤ Profilim", callback_data="my_stats"),
                     InlineKeyboardButton("ğŸ’¬ Bot ile Ã–zel Oyna", url=f"https://t.me/{context.bot.username}?start=fullgames")]
                ]
                keyboard = InlineKeyboardMarkup(keyboard_buttons)
                
                await query.edit_message_text(games_text, reply_markup=keyboard, parse_mode='Markdown')
            else:
                # For private chats, show solo games menu
                await show_enhanced_solo_games_menu(query, user, bot.casino, bot)
        elif data.startswith("solo_"):
            game_type = data.split("_", 1)[1]
            await show_enhanced_solo_game_options(query, user, f"solo_{game_type}", bot.casino, bot)
        
        # Handle individual dice games directly
        elif data in ["dice_classic", "dice_darts", "dice_basketball", "dice_football", "dice_bowling", "dice_slot_machine"]:
            try:
                from dice_games import handle_dice_game_options
                await handle_dice_game_options(query, user, bot.casino, data.split("_", 1)[1])
            except ImportError:
                await query.edit_message_text(
                    "ğŸ² Dice game is currently unavailable.",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )

        # Handle custom dice bet options
        elif data.startswith("custom_dice_"):
            dice_type = data.replace("custom_dice_", "")
            try:
                from dice_games import handle_custom_dice_bet
                await handle_custom_dice_bet(query, user, bot.casino, dice_type)
            except ImportError:
                await query.edit_message_text(
                    "ğŸ’ Custom bet feature is currently unavailable.",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )
        
        # TÃ¼m solo oyunlar iÃ§in callback handler'larÄ±
        elif data == "play_solo_slot":
            await handle_solo_game_menu(query, user, bot.casino, "solo_slots", "ğŸ° Slot Machine")
        elif data == "play_solo_roulette":
            await handle_solo_game_menu(query, user, bot.casino, "solo_roulette", "ğŸ”´ Roulette")
        elif data == "play_solo_blackjack":
            await handle_solo_game_menu(query, user, bot.casino, "solo_blackjack", "â™ ï¸ Blackjack")
        elif data == "play_solo_crash":
            await handle_solo_game_menu(query, user, bot.casino, "solo_crash", "ğŸš€ Crash")
        elif data == "play_solo_mines":
            await handle_solo_game_menu(query, user, bot.casino, "solo_mines", "â›ï¸ Mines")
        elif data == "play_solo_baccarat":
            await handle_solo_game_menu(query, user, bot.casino, "solo_baccarat", "ğŸƒ Baccarat")
        elif data == "play_solo_keno":
            await handle_solo_game_menu(query, user, bot.casino, "solo_keno", "ğŸ¯ Keno")
        elif data == "play_solo_dice":
            await handle_solo_game_menu(query, user, bot.casino, "solo_dice", "ğŸ² Dice")
        elif data == "play_rock_paper_scissors":
            await handle_new_solo_game_menu(query, user, bot.casino, "rock_paper_scissors", "âœ‚ï¸ TaÅŸ-KaÄŸÄ±t-Makas")
        elif data == "play_number_guess":
            await handle_new_solo_game_menu(query, user, bot.casino, "number_guess", "ğŸ”¢ SayÄ± Tahmin")
        
        # Group Solo Game Handlers (Fixed 100 coin bets) - All Games Available
        
        # Telegram Dice Games Handlers (6 games)
        elif data == "group_dice_slot_100":
            await handle_group_dice_game(query, user, bot.casino, "slot_machine", 100, "ğŸ° Dice Slot")
        elif data == "group_dice_football_100":
            await handle_group_dice_game(query, user, bot.casino, "football", 100, "âš½ Futbol")
        elif data == "group_dice_bowling_100":
            await handle_group_dice_game(query, user, bot.casino, "bowling", 100, "ğŸ³ Bowling")
        elif data == "group_dice_classic_100":
            await handle_group_dice_game(query, user, bot.casino, "classic", 100, "ğŸ² Klasik Zar")
        elif data == "group_dice_darts_100":
            await handle_group_dice_game(query, user, bot.casino, "darts", 100, "ğŸ¯ Dart")
        elif data == "group_dice_basketball_100":
            await handle_group_dice_game(query, user, bot.casino, "basketball", 100, "ğŸ€ Basketbol")
        elif data == "group_game_status":
            # Show current group game status (who is playing)
            chat_id = query.message.chat.id
            current_game = bot.get_group_game_status(chat_id)
            
            if current_game:
                locked_user = bot.casino.get_user_by_id(current_game['user_id'])
                username = locked_user['username'] if locked_user else "Bilinmeyen KullanÄ±cÄ±"
                time_passed = int(time.time() - current_game['timestamp'])
                
                status_text = f"""
â³ **GRUP OYUN DURUMU** â³

ğŸ® **Åu An Oynayan:** @{username}
ğŸ¯ **Oyun TÃ¼rÃ¼:** {current_game['game_type']}
â° **SÃ¼re:** {time_passed} saniye Ã¶nce baÅŸladÄ±

âš ï¸ LÃ¼tfen oyun bitene kadar bekleyiniz.
ğŸ’¡ Her seferinde sadece bir kiÅŸi oynayabilir!
                """
                
                await query.edit_message_text(
                    status_text,
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ”„ GÃ¼ncelle", "group_game_status")],
                        [("ğŸ® Oyunlara DÃ¶n", "games")]
                    ]),
                    parse_mode='Markdown'
                )
            else:
                await query.edit_message_text(
                    "âœ… **GRUP OYUN DURUMU**\n\n"
                    "ğŸ†“ Grup ÅŸu an oyun iÃ§in uygun!\n"
                    "ğŸ® Herhangi bir oyunu baÅŸlatabilirsin.\n\n"
                    "ğŸ’¡ Ä°lk oynayan kiÅŸi grup oyununu kilitler.",
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ® Oyun Oyna", "games")],
                        [("ğŸ“Š Grup Ä°statistikleri", "group_stats")]
                    ]),
                    parse_mode='Markdown'
                )
            return
            
        elif data == "group_stats":
            # Show detailed group statistics
            chat_id = query.message.chat.id
            group_stats = await get_group_stats(context.bot, chat_id, bot.casino)
            member_count = await get_group_member_count(context.bot, chat_id)
            
            stats_text = f"""
ğŸ“Š **DETAYLI GRUP Ä°STATÄ°STÄ°KLERÄ°** ğŸ“Š

ğŸ† **BUGÃœNKÃœ PERFORMANS:**
ğŸ¯ **Toplam Oyun:** {group_stats['games_today']} adet
ğŸ’° **Total Winnings:** {group_stats['winnings_today']:,} ğŸ»
ğŸ‘‘ **En Aktif Oyuncu:** {group_stats['top_player']}
ğŸ® **En Aktif Oyun SayÄ±sÄ±:** {group_stats['top_player_games']} oyun

ğŸ‘¥ **GRUP BÄ°LGÄ°LERÄ°:**
ğŸ‘¤ **Toplam Ãœye:** {member_count} kiÅŸi
ğŸ **GÃ¼nlÃ¼k Grup Bonusu:** {calculate_group_bonus(member_count):,} ğŸ»

ğŸ° **OYUN TÄ°PLERÄ° (En PopÃ¼ler):**
â€¢ Slot Machine
â€¢ Blackjack  
â€¢ Crash
â€¢ Roulette

ğŸ”¥ **Ã–ZELLÄ°KLER:**
â€¢ BÃ¼yÃ¼k kazanÃ§lar otomatik duyurulur
â€¢ GÃ¼nlÃ¼k grup bonusu
â€¢ CanlÄ± istatistikler
â€¢ Rekabet ortamÄ±

ğŸ“ˆ **SONUÃ‡:** Bu grup aktif bir casino topluluÄŸu!
            """
            
            await query.edit_message_text(
                stats_text,
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ”„ GÃ¼ncelle", "group_stats"), ("ğŸ® Oyunlara DÃ¶n", "game_menu_return")],
                    [("ğŸ‘¤ Profilim", "my_stats")]
                ]),
                parse_mode='Markdown'
            )
        elif data == "play_lucky_wheel":
            await handle_new_solo_game_menu(query, user, bot.casino, "lucky_wheel", "ğŸª Lucky Wheel")
        
        # Mevcut solo oyunlar iÃ§in bahis callback'leri
        elif data.startswith("play_game_"):
            # Format: play_game_GAMETYPE_BETAMOUNT
            parts = data.split("_")
            if len(parts) >= 4:
                game_type = parts[2]  # slots, roulette, blackjack, etc.
                try:
                    bet_amount = int(parts[3])
                    await handle_solo_game_play(query, user, bot.casino, game_type, bet_amount)
                except ValueError:
                    await query.edit_message_text("âŒ Invalid bet amount!")
        
        # Yeni oyunlar iÃ§in callback'ler
        elif data.startswith("play_new_game_"):
            # Format: play_new_game_GAMETYPE_BETAMOUNT
            parts = data.split("_")
            if len(parts) >= 5:
                game_type = parts[3]  # rock_paper_scissors, number_guess, lucky_wheel
                try:
                    bet_amount = int(parts[4])
                    await handle_new_solo_game_play(query, user, bot.casino, game_type, bet_amount)
                except ValueError:
                    await query.edit_message_text("âŒ Invalid bet amount!")
        
        # Ä°statistikler menÃ¼sÃ¼
        elif data == "my_stats":
            await show_user_stats(query, user, bot.casino)
        
        elif data.startswith("play_solo_"):
            parts = data.split("_")
            if len(parts) >= 4:
                game_type = f"{parts[1]}_{parts[2]}"
                try:
                    bet_amount = int(parts[3])
                except ValueError:
                    await query.edit_message_text(
                        "âŒ Invalid bet amount!",
                        reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                    )
                    return
                
                # Enhanced bet validation
                validation = bot.validate_bet_amount(user['user_id'], bet_amount, user['fun_coins'])
                if not validation['valid']:
                    await query.edit_message_text(
                        validation['reason'],
                        reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                    )
                    return
                
                if HANDLERS_AVAILABLE:
                    await handle_enhanced_solo_game(query, user, game_type, bet_amount, bot.casino, bot)
                else:
                    await handle_simple_solo_game(query, user, game_type, bet_amount, bot.casino)
        
        # Enhanced profile and other features  
        elif data == "profile":
            await show_enhanced_profile(query, user, bot.casino, bot)
        elif data == "daily_quests":
            if HANDLERS_AVAILABLE:
                await show_daily_quests(query, user, bot.casino)
            else:
                await show_simple_daily_quests(query, user, bot.casino)
        elif data == "achievements":
            if HANDLERS_AVAILABLE:
                await show_achievements(query, user, bot.casino)
            else:
                await show_simple_achievements(query, user, bot.casino)
        elif data == "leaderboard":
            if HANDLERS_AVAILABLE:
                await show_leaderboard(query, bot.casino)
            else:
                await show_simple_leaderboard(query, bot.casino)
        elif data == "leaderboard_daily":
            if HANDLERS_AVAILABLE:
                await show_leaderboard(query, bot.casino, "daily")
            else:
                await show_simple_leaderboard(query, bot.casino)
        elif data == "leaderboard_weekly":
            if HANDLERS_AVAILABLE:
                await show_leaderboard(query, bot.casino, "weekly")
            else:
                await show_simple_leaderboard(query, bot.casino)
        elif data == "leaderboard_monthly":
            if HANDLERS_AVAILABLE:
                await show_leaderboard(query, bot.casino, "monthly")
            else:
                await show_simple_leaderboard(query, bot.casino)
        elif data == "leaderboard_all":
            if HANDLERS_AVAILABLE:
                await show_leaderboard(query, bot.casino, "all_time")
            else:
                await show_simple_leaderboard(query, bot.casino)
        elif data == "tournaments":
            await show_tournament_menu(query, user, bot.casino)
        elif data == "friends":
            if HANDLERS_AVAILABLE:
                from other_handlers import show_friends
                await show_friends(query, user, bot.casino)
            else:
                await show_simple_friends_menu(query, user, bot.casino)
        elif data == "events":
            await show_events_menu(query, user, bot.casino)
        elif data == "bonus_features":
            if BONUS_MENU_AVAILABLE:
                await show_bonus_features_menu(query, user, bot.casino)
            else:
                await query.edit_message_text(
                    "ERROR: Bonus features not available. Please try again later.",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
                )
        elif data == "daily_spinner":
            if HANDLERS_AVAILABLE:
                await show_daily_spinner(query, user, bot.casino)
            else:
                await query.edit_message_text(
                    "ERROR: Bonus features not available. Please try again later.",
                    reply_markup=bot.casino.create_keyboard([[('ğŸ  Main Menu', 'main_menu')]])
                )
        elif data == "fortune_wheel":
            if HANDLERS_AVAILABLE:
                await show_fortune_wheel(query, user, bot.casino)
            else:
                await query.edit_message_text(
                    "ERROR: Bonus features not available. Please try again later.",
                    reply_markup=bot.casino.create_keyboard([[('ğŸ  Main Menu', 'main_menu')]])
                )
        elif data == "mystery_box":
            if HANDLERS_AVAILABLE:
                await show_mystery_box(query, user, bot.casino)
            else:
                await query.edit_message_text(
                    "ERROR: Bonus features not available. Please try again later.",
                    reply_markup=bot.casino.create_keyboard([[('ğŸ  Main Menu', 'main_menu')]])
                )
        elif data == "achievement_showcase":
            if HANDLERS_AVAILABLE:
                await show_achievement_showcase(query, user, bot.casino)
            else:
                await query.edit_message_text(
                    "ERROR: Bonus features not available. Please try again later.",
                    reply_markup=bot.casino.create_keyboard([[('ğŸ  Main Menu', 'main_menu')]])
                )
        elif data.startswith("create_tournament_"):
            tournament_type = data.split("_", 2)[2]
            await handle_create_tournament(query, user, tournament_type, bot.casino)
        elif data.startswith("join_tournament_"):
            tournament_id = data.split("_", 2)[2]
            await handle_join_tournament(query, user, tournament_id, bot.casino)
        elif data == "add_friend":
            from other_handlers import show_add_friend_menu
            await show_add_friend_menu(query, user, bot.casino)
        elif data == "friend_requests":
            from other_handlers import show_friend_requests_menu
            await show_friend_requests_menu(query, user, bot.casino)
        elif data == "referral_stats":
            from other_handlers import show_referral_stats
            await show_referral_stats(query, user, bot.casino)
        elif data == "copy_friend_code":
            await query.answer("ğŸ“‹ Your friend code copied to clipboard!")
        elif data == "share_friend_code":
            await query.answer("ğŸ“¤ Your friend code is ready for sharing!")
        elif data == "enter_friend_code":
            await query.edit_message_text(
                "ğŸ” **ENTER FRIEND CODE** ğŸ”\n\n"
                "ğŸ“ **How it works:**\n"
                "â€¢ Ask your friend for their 6-digit code\n"
                "â€¢ Type the code in this chat (e.g.: ABC123)\n"
                "â€¢ Friend request will be sent automatically\n\n"
                "ğŸ’¡ **Example code format:** ABC123\n"
                "ğŸ”¤ **Note:** Case doesn't matter!\n\n"
                "ğŸ‘‡ **Enter the friend code now:**",
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ”™ Back", "add_friend"), ("ğŸ‘¥ My Friends", "friends")],
                    [("ğŸ  Main Menu", "main_menu")]
                ]),
                parse_mode='Markdown'
            )
        elif data.startswith("accept_friend_"):
            friend_id = int(data.split("_", 2)[2])
            await handle_accept_friend(query, user, friend_id, bot.casino)
        elif data.startswith("reject_friend_"):
            friend_id = int(data.split("_", 2)[2])
            await handle_reject_friend(query, user, friend_id, bot.casino)
        
        # Admin commands
        elif data == "admin_panel" and is_admin_user(user['user_id']):
            await show_admin_panel(query, user, bot.casino)
        elif data == "admin_stats" and is_admin_user(user['user_id']):
            await show_admin_statistics(query, user, bot.casino)
        elif data == "admin_users" and is_admin_user(user['user_id']):
            await show_admin_user_management(query, user, bot.casino)
        elif data == "admin_broadcast" and is_admin_user(user['user_id']):
            await show_admin_broadcast_menu(query, user, bot.casino)
        elif data == "admin_broadcast_general" and is_admin_user(user['user_id']):
            await handle_admin_broadcast_general(query, user, bot.casino)
        elif data == "admin_broadcast_maintenance" and is_admin_user(user['user_id']):
            await handle_admin_broadcast_maintenance(query, user, bot.casino)
        elif data == "admin_broadcast_custom" and is_admin_user(user['user_id']):
            await handle_admin_broadcast_custom(query, user, bot.casino)
        elif data == "admin_broadcast_templates" and is_admin_user(user['user_id']):
            await handle_admin_broadcast_templates(query, user, bot.casino)
        elif data == "admin_settings" and is_admin_user(user['user_id']):
            await show_admin_settings(query, user, bot.casino)
        elif data.startswith("admin_user_") and is_admin_user(user['user_id']):
            parts = data.split("_")
            if len(parts) >= 4:
                action = parts[2]
                target_user_id = int(parts[3])
                await handle_admin_user_action(query, user, action, target_user_id, bot.casino)
        
        # Duel system
        elif data == "create_duel":
            await query.edit_message_text(
                "ğŸ”œ **YAKINDA** ğŸ”œ\n\nâš”ï¸ DÃ¼ello sistemi yakÄ±nda gelecek!\n\nğŸš§ Åu anda geliÅŸtirme aÅŸamasÄ±nda...",
                reply_markup=bot.casino.create_keyboard([[("ğŸ  Ana MenÃ¼", "main_menu")]])
            )
        elif data == "join_duel":
            await query.edit_message_text(
                "ğŸ”œ **YAKINDA** ğŸ”œ\n\nğŸ¯ DÃ¼elloya katÄ±lma Ã¶zelliÄŸi yakÄ±nda gelecek!\n\nğŸš§ Åu anda geliÅŸtirme aÅŸamasÄ±nda...",
                reply_markup=bot.casino.create_keyboard([[("ğŸ  Ana MenÃ¼", "main_menu")]])
            )
        elif data.startswith("create_duel_"):
            game_type = data.split("_", 2)[2]
            await handle_create_duel(query, user, game_type, bot.casino)
        elif data.startswith("join_"):
            game_id = data.split("_", 1)[1]
            await handle_join_game(query, user, game_id, bot.casino)
        
        # Enhanced daily bonus
        elif data == "daily_bonus":
            try:
                bonus_result = bot.casino.get_daily_bonus(user['user_id'])
                if bonus_result['success']:
                    # VIP bonus ekle
                    vip_level = bot.get_user_vip_level(user['user_id'])
                    if vip_level > 0:
                        vip_bonus = VIP_LEVELS[vip_level]['daily_bonus']
                        with bot.casino.db.get_connection() as conn:
                            conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?', 
                                       (vip_bonus, user['user_id']))
                            conn.commit()
                        
                        text = f"ğŸ **DAILY BONUS RECEIVED!** ğŸ\n\n"
                        text += f"ğŸ» **Standard Bonus:** +{bonus_result['bonus']} ğŸ»\n"
                        text += f"ğŸ‘‘ **VIP {vip_level} Bonus:** +{vip_bonus} ğŸ»\n"
                        text += f"âœ¨ **Total:** +{bonus_result['bonus'] + vip_bonus} ğŸ»\n\n"
                        text += f"ğŸŒŸ Take advantage of VIP benefits!"
                    else:
                        text = f"ğŸ **DAILY BONUS RECEIVED!** ğŸ\n\nğŸ» +{bonus_result['bonus']} Fun Coins ğŸŒŸ\n\nğŸ‘‘ Earn more bonuses as VIP!"
                else:
                    text = f"ERROR: {bonus_result['message']}"
                    
                # Achievement check
                if bonus_result.get('success'):
                    bot.casino.unlock_achievement(user['user_id'], "daily_login")
                    
            except Exception as e:
                logger.error(f"Daily bonus error: {e}")
                text = "ERROR: Failed to get bonus. Please try again later."
                
            await query.edit_message_text(
                text,
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ® Play Game", "solo_games"), ("ğŸ“Š Profile", "profile")],
                    [("ğŸ‘‘ Become VIP", "vip_info"), ("ğŸ  Main Menu", "main_menu")]
                ]),
                parse_mode='Markdown'
            )
        
        # Handle insufficient funds
        elif data == "insufficient_funds":
            await query.edit_message_text(
                "ğŸ’¸ Insufficient balance! To play games or make investments:",
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ’³ Make Deposit", "deposit_menu"), ("ğŸ Daily Bonus", "daily_bonus")],
                    [("ğŸ® Low Stake Games", "solo_games"), ("ğŸ  Main Menu", "main_menu")]
                ])
            )
        
        # Redirect dice_games to solo_games (merged)
        elif data == "dice_games":
            await show_enhanced_solo_games_menu(query, user, bot.casino, bot)
        elif data.startswith("dice_game_options_"):
            try:
                dice_type = data.split("_", 3)[3]
                from dice_games import handle_dice_game_options
                await handle_dice_game_options(query, user, bot.casino, dice_type)
            except (ImportError, IndexError):
                await query.edit_message_text(
                    "âŒ Dice game error!",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )
        elif data.startswith("play_dice_"):
            try:
                # Remove "play_dice_" prefix to get the remaining part
                remaining = data[10:]  # len("play_dice_") = 10
                
                # Find the last underscore which separates dice_type from bet_amount
                last_underscore = remaining.rfind("_")
                if last_underscore == -1:
                    raise ValueError("Invalid dice callback format")
                
                dice_type = remaining[:last_underscore]
                bet_amount = int(remaining[last_underscore + 1:])
                
                from dice_games import handle_play_dice_game
                await handle_play_dice_game(query, user, bot.casino, dice_type, bet_amount)
            except (ImportError, ValueError, IndexError) as e:
                logger.error(f"Dice play error: {e}")
                await query.edit_message_text(
                    "âŒ Dice game error!",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )
        elif data == "dice_stats":
            try:
                from dice_games import handle_dice_statistics
                await handle_dice_statistics(query, user, bot.casino)
            except ImportError:
                await query.edit_message_text(
                    "ğŸ“Š Statistics are currently unavailable.",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )
        elif data.startswith("dice_"):
            # Handle individual dice game types
            try:
                dice_type = data.split("_", 1)[1]
                from dice_games import handle_dice_game_options
                await handle_dice_game_options(query, user, bot.casino, dice_type)
            except (ImportError, IndexError):
                await query.edit_message_text(
                    "âŒ Invalid dice game!",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                )
        
        # Handle play_ callbacks for different game types 
        elif data.startswith("play_"):
            parts = data.split("_")
            if len(parts) >= 3:
                try:
                    game_type = f"{parts[1]}_{parts[2]}" if len(parts) >= 3 else parts[1]
                    bet_amount = int(parts[-1]) if parts[-1].isdigit() else 10
                    
                    # Use simple game handler if enhanced not available
                    await handle_simple_solo_game(query, user, game_type, bet_amount, bot.casino)
                except (ValueError, IndexError) as e:
                    logger.error(f"Play callback error: {e}")
                    await query.edit_message_text(
                        "âŒ Invalid game data!",
                        reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
                    )
        
        # Handle VIP info
        elif data == "vip_info":
            await show_vip_info(query, user, bot)
        
        # Handle game history
        elif data == "game_history":
            await show_game_history(query, user, bot.casino)
        
        # Handle settings
        elif data == "settings":
            await show_settings_menu(query, user, bot.casino)
        
        # Handle language selection  
        elif data == "language":
            try:
                from language_handler import show_language_selection
                await show_language_selection(query, user, bot.casino)
            except ImportError:
                await query.edit_message_text(
                    "ğŸŒ Language selection is currently unavailable.",
                    reply_markup=bot.casino.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
                )
        
        # Handle notifications settings
        elif data == "notifications":
            await show_notifications_settings(query, user, bot.casino)
        elif data == "notifications_off":
            await query.edit_message_text(
                "ğŸ”• All notifications have been turned off!\n\nâš™ï¸ You can turn them on anytime from settings.",
                reply_markup=bot.casino.create_keyboard([[("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]])
            )
        elif data == "notifications_on":
            await query.edit_message_text(
                "ğŸ”” All notifications have been turned on!\n\nğŸ“± You will now be notified of all updates.",
                reply_markup=bot.casino.create_keyboard([[("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]])
            )
        
        # Handle privacy settings
        elif data == "privacy":
            await show_privacy_settings(query, user, bot.casino)
        elif data == "privacy_private":
            await query.edit_message_text(
                "ğŸ”’ Your profile is now private!\n\nğŸ‘¤ Only your friends can see your information.",
                reply_markup=bot.casino.create_keyboard([[("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]])
            )
        elif data == "privacy_public":
            await query.edit_message_text(
                "ğŸŒ Your profile is now public!\n\nğŸ“Š All users can see your statistics.",
                reply_markup=bot.casino.create_keyboard([[("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]])
            )
        
        elif data.startswith("https://") or data.startswith("http://"):
            import webbrowser
            try:
                webbrowser.open(data)
                await query.answer("ğŸŒ Link opening in browser...")
            except Exception as e:
                logger.error(f"Error opening URL {data}: {e}")
                await query.answer("âŒ Could not open link")
        
        # Group game callbacks - Fixed for "Tekrar Oyna" functionality
        elif data.startswith("group_") and "_" in data:
            parts = data.split("_")
            if len(parts) >= 3:
                try:
                    # Handle group_GAMETYPE_BETAMOUNT format
                    game_type = "_".join(parts[1:-1])  # Everything between "group_" and the last part (bet amount)
                    bet_amount = int(parts[-1])  # Last part is the bet amount
                    
                    # Check if we're in a group chat
                    if not is_group_chat(query):
                        await query.edit_message_text(
                            "âŒ Grup oyunlarÄ± sadece grup sohbetlerinde oynanabilir!",
                            reply_markup=bot.casino.create_keyboard([[("ğŸ® Solo Oyunlar", "solo_games"), ("ğŸ  Ana MenÃ¼", "main_menu")]])
                        )
                        return
                    
                    # Use independent group game handler
                    from independent_group_game_handler import handle_independent_group_game
                    await handle_independent_group_game(query, user, bot.casino, game_type, bet_amount)
                    
                except ValueError:
                    logger.error(f"Invalid bet amount in group game callback: {data}")
                    await query.edit_message_text("âŒ GeÃ§ersiz bahis miktarÄ±!")
                except Exception as e:
                    logger.error(f"Group game callback error: {e}")
                    await query.edit_message_text("âŒ Oyun baÅŸlatÄ±lamadÄ±, tekrar deneyiniz!")
        
        else:
            logger.warning(f"Unknown callback data received: {data}")
            await query.edit_message_text(
                f"âŒ Unknown command: '{data}'\n\nğŸ”„ Redirecting to main menu...",
                reply_markup=bot.casino.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            
    except Exception as e:
        # Check if the error is just "Message is not modified"
        if "Message is not modified" in str(e):
            logger.debug(f"Callback handler: Message content unchanged, skipping update - {e}")
            return
        
        logger.error(f"Callback handler error: {e}")
        await safe_query_edit(query,
            "ERROR: An error occurred! Returning to main menu...",
            reply_markup=bot.casino.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

# Simplified helper functions for basic functionality
async def show_simple_solo_games_menu(query, user, casino_bot):
    """Simple solo games menu"""
    try:
        buttons = [
            [("ğŸ° Dice Slots", "dice_slot_machine"), ("ğŸ¯ Dart Game", "dice_darts")],
            [("ğŸ² Classic Dice", "dice_classic"), ("ğŸ€ Basketball", "dice_basketball")],
            [("âš½ Football", "dice_football"), ("ğŸ³ Bowling", "dice_bowling")],
            [("ğŸ¯ Roulette", "solo_roulette"), ("ğŸƒ Blackjack", "solo_blackjack")],
            [("ğŸš€ Crash", "solo_crash"), ("ğŸ’£ Mines", "solo_mines")],
            [("ğŸ´ Baccarat", "solo_baccarat"), ("ğŸ”¢ Keno", "solo_keno")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        keyboard = casino_bot.create_keyboard(buttons)
        
        text = f"""
ğŸ® **SOLO GAMES** ğŸ®

ğŸ» **Current Balance:** {user['fun_coins']:,} ğŸ»

ğŸ¯ **TELEGRAM DICE GAMES:**
ğŸ° **Dice Slots** - 3 makara, 64 kombinasyon!
ğŸ¯ **Dart Game** - Bullseye target shooting!
ğŸ² **Classic Dice** - 6-sided classic die!
ğŸ€ **Basketball** - Basketball shooting game!
âš½ **Football** - Goal shooting game!
ğŸ³ **Bowling** - Pin knockdown game!

ğŸ¯ **CLASSIC CASINO GAMES:**
ğŸ¯ **Roulette** - Red or black?
ğŸƒ **Blackjack** - Reach 21!
ğŸš€ **Crash** - Cash out in time!
ğŸ’£ **Mines** - Avoid the mines!
ğŸ´ **Baccarat** - Banker vs Player
ğŸ”¢ **Keno** - Pick your numbers!

ğŸŒŸ Which game would you like to play?
        """
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Solo games menu error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading menu.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_simple_solo_game_options(query, user, game_type, casino_bot):
    """Simple game options"""
    try:
        from config import SOLO_GAMES
        
        game_config = SOLO_GAMES.get(game_type)
        if not game_config:
            await query.edit_message_text("âŒ Invalid game type!", 
                reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]]))
            return
        
        # Basic bet options
        balance = user['fun_coins']
        min_bet = game_config['min_bet']
        
        buttons = []
        for multiplier in [1, 5, 10, 25, 50]:
            bet = min_bet * multiplier
            if bet <= balance:
                buttons.append([(f"ğŸ» {bet:,} ğŸ»", f"play_{game_type}_{bet}")])
            else:
                buttons.append([(f"âŒ {bet:,} ğŸ» (Insufficient)", "insufficient_funds")])
        
        buttons.append([("ğŸ”™ Back", "solo_games"), ("ğŸ  Main Menu", "main_menu")])
        
        keyboard = casino_bot.create_keyboard(buttons)
        
        text = f"""
ğŸ® **{game_config['name'].upper()}** ğŸ®

ğŸ» **Mevcut Bakiye:** {balance:,} ğŸ»
ğŸ’ **Minimum Bet:** {min_bet:,} ğŸ»

ğŸ² **Choose your bet amount:**
        """
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Solo game options error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading game options.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
        )

async def handle_simple_solo_game(query, user, game_type, bet_amount, casino_bot):
    """Basit solo oyun handler"""
    try:
        # Create solo game engine
        solo_engine = SoloGameEngine()
        
        # Play game based on type
        if game_type == "solo_slots":
            result = solo_engine.play_solo_slots(bet_amount, user['user_id'])
        elif game_type == "solo_roulette":
            result = solo_engine.play_solo_roulette(bet_amount, "color", "red", user['user_id'])
        elif game_type == "solo_blackjack":
            result = solo_engine.play_solo_blackjack(bet_amount, user['user_id'])
        elif game_type == "solo_crash":
            result = solo_engine.play_solo_crash(bet_amount, 2.0, user['user_id'])
        elif game_type == "solo_mines":
            result = solo_engine.play_solo_mines(bet_amount, 3, 5, user['user_id'])
        elif game_type == "solo_baccarat":
            result = solo_engine.play_solo_baccarat(bet_amount, "player", user['user_id'])
        elif game_type == "solo_keno":
            result = solo_engine.play_solo_keno(bet_amount, [1, 2, 3, 4, 5], user['user_id'])
        elif game_type == "solo_dice":
            result = solo_engine.play_solo_dice(bet_amount, 4, user['user_id'])
        else:
            await query.edit_message_text("âŒ Unknown game type!")
            return
        
        # Update user balance and stats
        casino_bot.update_user_stats(user['user_id'], bet_amount, result['win_amount'], result['won'])
        casino_bot.save_solo_game(user['user_id'], game_type, bet_amount, result)
        
        # Show result
        if result['won']:
            emoji = "ğŸ‰"
            status = "YOU WON!"
        else:
            emoji = "ğŸ˜¢"
            status = "You lost!"
        
        result_text = f"""
{emoji} **{status}** {emoji}

ğŸ® **Game:** {game_type.replace('solo_', '').title()}
ğŸ» **Bet:** {bet_amount:,} ğŸ»
ğŸ¯ **Winnings:** {result['win_amount']:,} ğŸ»
ğŸ“Š **Multiplier:** {result['multiplier'] if 'multiplier' in result else 0:.2f}x

ğŸ’µ **New Balance:** {user['fun_coins'] - bet_amount + result['win_amount']:,} ğŸ»
        """
        
        buttons = [
            [("ğŸ® Play Again", f"solo_{game_type.split('_')[1]}"), ("ğŸ¯ Other Game", "solo_games")],
            [("ğŸ“Š Profile", "profile"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Simple solo game error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while playing the game.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
        )

async def show_simple_profile(query, user, casino_bot):
    """Simple profile display"""
    try:
        stats = casino_bot.get_user_stats(user['user_id'])
        
        text = f"""
ğŸ‘¤ **PROFILE** ğŸ‘¤

ğŸ†” **User:** @{user['username'] or 'Anonymous'}
ğŸ» **Balance:** {user['fun_coins']:,} ğŸ»
â­ **Level:** {user['level'] if 'level' in user else 1}
ğŸ¯ **XP:** {user['xp'] if 'xp' in user else 0:,}
ğŸ† **Win Rate:** {stats['win_rate'] if 'win_rate' in stats else 0:.1f}%

ğŸ“Š **Statistics:**
Total Games: {stats['total_games'] if 'total_games' in stats else 0:,}
ğŸ† Won: {stats['games_won'] if 'games_won' in stats else 0:,}
ğŸ’¸ Lost: {stats['games_lost'] if 'games_lost' in stats else 0:,}
ğŸ’ Biggest Win: {stats['biggest_win'] if 'biggest_win' in stats else 0:,} ğŸ»
        """
        
        buttons = [
            [("ğŸ Daily Bonus", "daily_bonus"), ("ğŸ† Achievements", "achievements")],
            [("ğŸ® Back to Games", "solo_games"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Simple profile error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading profile.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_simple_daily_quests(query, user, casino_bot):
    """Simple daily quests"""
    try:
        quests = casino_bot.get_daily_quests(user['user_id'])
        
        text = "ğŸ <b>DAILY QUESTS</b> ğŸ\n\n"
        
        for quest in quests:
            progress = quest['progress']
            target = quest['target']
            reward = quest['reward']
            completed = quest['completed']
            
            if completed:
                status = "Completed"
            else:
                status = f"ğŸ“Š {progress}/{target}"
            
            text += f"â€¢ <b>{quest['quest_type']}</b>: {status} - {reward} ğŸ»\n"
        
        buttons = [
            [("ğŸ® Play Game", "solo_games"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]

        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='HTML')

    except Exception as e:
        logger.error(f"Daily quests error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading quests.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_simple_achievements(query, user, casino_bot):
    """Basit achievementslar"""
    try:
        achievements = casino_bot.get_user_achievements(user['user_id'])
        
        text = f"ğŸ† **YOUR ACHIEVEMENTS** ğŸ†\n\n"
        text += f"ğŸ“Š **Toplam:** {len(achievements)} achievements\n\n"
        
        if achievements:
            for ach in achievements[:5]:  # Show first 5
                text += f"ğŸ… **{ach['name'] if 'name' in ach else 'Achievement'}** - {ach['reward'] if 'reward' in ach else 0} ğŸ»\n"
            
            if len(achievements) > 5:
                text += f"... ve {len(achievements)-5} tane daha\n"
        else:
            text += "No achievements yet. Play games to earn achievements!\n"
        
        buttons = [
            [("ğŸ® Play Game", "solo_games"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Achievements error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading achievements.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_simple_leaderboard(query, casino_bot):
    """Basit liderlik tablosu"""
    try:
        with casino_bot.db.get_connection() as conn:
            top_users = conn.execute('''SELECT username, fun_coins, level 
                FROM users ORDER BY fun_coins DESC LIMIT 10''').fetchall()
        
        text = "ğŸ† **LEADERBOARD** ğŸ†\n\n"
        
        for i, user in enumerate(top_users, 1):
            medal = "ğŸ¥‡" if i == 1 else "ğŸ¥ˆ" if i == 2 else "ğŸ¥‰" if i == 3 else f"{i}."
            text += f"{medal} **@{user['username'] or 'Anonim'}** - {user['fun_coins']:,} ğŸ» (Lv.{user['level']})\n"
        
        buttons = [
            [("ğŸ“Š Profil", "profile"), ("ğŸ® Play Game", "solo_games")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Leaderboard error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading leaderboard.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

# Original enhanced functions (keep for compatibility)
async def show_enhanced_solo_games_menu(query, user, casino_bot, bot_instance):
    """Enhanced solo games menu with VIP info"""
    try:
        vip_level = bot_instance.get_user_vip_level(user['user_id'])
        max_bet = bot_instance.get_user_max_bet(user['user_id'])
        
        buttons = [
            [("ğŸ° Dice Slots", "dice_slot_machine"), ("ğŸ¯ Dart Game", "dice_darts"), ("ğŸ² Classic Dice", "dice_classic")],
            [("ğŸ€ Basketball", "dice_basketball"), ("âš½ Football", "dice_football"), ("ğŸ³ Bowling", "dice_bowling")],
            [("ğŸ¯ Roulette", "solo_roulette"), ("ğŸƒ Blackjack", "solo_blackjack"), ("ğŸš€ Crash", "solo_crash")],
            [("ğŸ’£ Mines", "solo_mines"), ("ğŸ´ Baccarat", "solo_baccarat"), ("ğŸ”¢ Keno", "solo_keno")],
            [("ğŸ“Š Game History", "solo_history"), ("ğŸ  Main Menu", "main_menu")]
        ]
        keyboard = casino_bot.create_keyboard(buttons)
        
        vip_text = f"ğŸ‘‘ VIP {vip_level}" if vip_level > 0 else "ğŸ†• Standart"
        
        text = f"""
ğŸ® **SOLO GAMES** ğŸ®

ğŸ» **Current Coins:** {user['fun_coins']:,}
ğŸ¯ **VIP Level:** {vip_text}
ğŸš« **Maximum Bet:** {max_bet:,} ğŸ»

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ TELEGRAM DICE GAMES â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ° **Dice Slots** - 64 kombinasyon! â”‚
â”‚ ğŸ¯ **Dart Game** - Bullseye x10!    â”‚
â”‚ ğŸ² **Classic Dice** - 6 sided die!  â”‚
â”‚ ğŸ€ **Basketball** - Basket shooting!   â”‚
â”‚ âš½ **Football** - Gol shot!         â”‚
â”‚ ğŸ³ **Bowling** - Strike bonusu!     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€ CLASSIC CASINO GAMES â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¯ **Roulette** - Red/Black?    â”‚
â”‚ ğŸƒ **Blackjack** - Reach 21!       â”‚
â”‚ ğŸš€ **Crash** - Timing is key!    â”‚
â”‚ ğŸ’£ **Mines** - Dodge the mines!     â”‚
â”‚ ğŸ´ **Baccarat** - Banker or Player?        â”‚
â”‚ ğŸ”¢ **Keno** - Pick the numbers!         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ’¡ **VIP Advantages:**
â€¢ Higher bet limits
â€¢ Bonus multipliers
â€¢ Priority support

ğŸŒŸ Which solo adventure are you ready for?
        """
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Enhanced solo games menu error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading menu.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_enhanced_solo_game_options(query, user, game_type, casino_bot, bot_instance):
    """Enhanced solo game options with smart bet suggestions"""
    try:
        from config import SOLO_GAMES
        
        game_config = SOLO_GAMES.get(game_type)
        if not game_config:
            await query.edit_message_text("âŒ Invalid game type!", 
                reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]]))
            return
        
        vip_level = bot_instance.get_user_vip_level(user['user_id'])
        max_bet = bot_instance.get_user_max_bet(user['user_id'])
        
        # Get smart bet suggestions
        suggestions = bot_instance.get_bet_suggestion(user['fun_coins'], vip_level)
        
        buttons = []
        for bet in suggestions:
            if user['fun_coins'] >= bet:
                percentage = (bet / user['fun_coins']) * 100
                buttons.append([(f"ğŸ» {bet:,} ğŸ» ({percentage:.1f}%)", f"play_{game_type}_{bet}")])
            else:
                buttons.append([(f"âŒ {bet:,} ğŸ» (Insufficient)", "insufficient_funds")])
        
        # Add custom amount option
        min_bet = game_config['min_bet']
        if len(buttons) < 6:
            for multiplier in [1, 2, 5, 10]:
                custom_bet = min_bet * multiplier
                if custom_bet not in suggestions and custom_bet <= user['fun_coins'] and custom_bet <= max_bet:
                    buttons.append([(f"ğŸ² {custom_bet:,} ğŸ»", f"play_{game_type}_{custom_bet}")])
        
        # Add navigation buttons
        buttons.append([("ğŸ”™ Back", "solo_games"), ("ğŸ  Main Menu", "main_menu")])
        
        keyboard = casino_bot.create_keyboard(buttons)
        
        game_name = game_config['name']
        game_description = game_config.get('description', 'Fun casino game!')
        
        text = f"""
ğŸ® **{game_name.upper()}** ğŸ®

ğŸ“ **Description:** {game_description}

ğŸ» **Current Balance:** {user['fun_coins']:,} ğŸ»
ğŸ¯ **VIP Level:** {vip_level}
ğŸš« **Maximum Bet:** {max_bet:,} ğŸ»
ğŸ’ **Minimum Bet:** {min_bet:,} ğŸ»

ğŸ² **BAHIS AMOUNT CHOOSE:**

ğŸ’¡ **Tips:**
â€¢ With small bets start
â€¢ VIP olarak higher limits
â€¢ Determine your winning strategy

ğŸŒŸ Hangi miktarla oynamak istiyorsunz?
        """
        
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Enhanced solo game options error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading game options.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
        )

async def show_enhanced_profile(query, user, casino_bot, bot_instance):
    """Enhanced profile with VIP and payment info"""
    try:
        # Helper function to safely get values from user (handles both dict and sqlite3.Row)
        def safe_get(obj, key, default=None):
            try:
                # Check if it's a dictionary with get method
                if hasattr(obj, 'get') and not hasattr(obj, 'keys'):
                    return obj.get(key, default)
                # For sqlite3.Row or dict-like objects
                elif hasattr(obj, 'keys'):
                    return obj[key] if key in obj.keys() and obj[key] is not None else default
                else:
                    return obj[key] if key in dict(obj) else default
            except:
                return default
        
        vip_level = bot_instance.get_user_vip_level(user['user_id'])
        max_bet = bot_instance.get_user_max_bet(user['user_id'])
        
        # Get user stats
        stats = casino_bot.get_user_stats(user['user_id'])
        
        # Get payment stats if available
        if bot_instance.payment_manager:
            try:
                payment_stats = bot_instance.payment_manager.get_user_payment_stats(user['user_id'])
                total_deposited = payment_stats['total_deposits'] if 'total_deposits' in payment_stats else 0
                total_withdrawn = payment_stats['total_withdrawals'] if 'total_withdrawals' in payment_stats else 0
                net_position = total_deposited - total_withdrawn
            except:
                total_deposited = 0
                total_withdrawn = 0
                net_position = 0
        else:
            total_deposited = 0
            total_withdrawn = 0
            net_position = 0
        
        # Calculate next VIP level requirements
        next_vip_level = vip_level + 1
        next_vip_requirement = 0
        remaining_for_next_vip = 0
        
        if next_vip_level <= 5 and next_vip_level in VIP_LEVELS:
            next_vip_requirement = VIP_LEVELS[next_vip_level]['min_deposit']
            remaining_for_next_vip = max(0, next_vip_requirement - total_deposited)
        
        vip_status = f"ğŸ‘‘ VIP {vip_level}" if vip_level > 0 else "ğŸ†• Standart Member"
        
        text = f"""
ğŸ‘¤ **PROFILE INFORMATION** ğŸ‘¤

ğŸ†” **User:** @{user['username'] or 'Anonymous'}
ğŸ» **Bakiye:** {user['fun_coins']:,} Fun Coins
â­ **Seviye:** {safe_get(user, 'level', 1)}
ğŸ¯ **XP:** {safe_get(user, 'xp', 0) or 0:,}
ğŸ† **VIP Durumu:** {vip_status}

ğŸ“Š **GAME STATISTICS**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
Total Games: {stats.get('total_games', 0) or 0:,}
ğŸ† Won: {stats.get('games_won', 0) or 0:,}
ğŸ’¸ Lost: {stats.get('games_lost', 0) or 0:,}
ğŸ“ˆ Win Rate: {stats.get('win_rate', 0) or 0:.1f}%
ğŸ’ Biggest Win: {stats.get('biggest_win', 0) or 0:,} ğŸ»
ğŸ“‰ Biggest Loss: {stats.get('biggest_loss', 0) or 0:,} ğŸ»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ’³ **PAYMENT STATISTICS**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸ“¥ Total Deposits: {total_deposited:,} ğŸ»
ğŸ“¤ Total Withdrawals: {total_withdrawn:,} ğŸ»
ğŸ“Š Net Pozisyon: {net_position:+,} ğŸ»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ² **BET LIMITS**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸš« Maksimum Bahis: {max_bet:,} ğŸ»
ğŸ¯ Daily Limit: Unlimited
ğŸ’ VIP Advantages: {'Active' if vip_level > 0 else 'Inactive'}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""
        
        if next_vip_level <= 5:
            text += f"""
ğŸ¯ **SONRAKÄ° VIP SEVÄ°YE**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸ† Hedef: VIP {next_vip_level}
ğŸ» Gerekli: {next_vip_requirement:,} ğŸ»
ğŸ“ˆ Kalan: {remaining_for_next_vip:,} ğŸ»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
"""
        
        # Get achievements
        achievements = casino_bot.get_user_achievements(user['user_id'])
        if achievements:
            text += f"\nğŸ… **ACHIEVEMENTS** ({len(achievements)} items)\n"
            for ach in achievements[:3]:  # Show first 3
                text += f"â€¢ {safe_get(ach, 'name', 'Achievement')}\n"
            if len(achievements) > 3:
                text += f"â€¢ ... ve {len(achievements)-3} tane daha\n"
        
        buttons = [
            [("ğŸ Daily Bonus", "daily_bonus"), ("ğŸ† Achievements", "achievements")],
            [("ğŸ’³ Payment Transactions", "payment_menu"), ("ğŸ‘‘ Become VIP", "vip_info")],
            [("ğŸ“Š Liderlik Tablosu", "leaderboard"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Enhanced profile error: {e}")
        await query.edit_message_text(
            "âŒ Error occurred while loading profile.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Help command handler"""
    help_text = """
**CASINO BOT HELP**

ğŸ¯ **Main Commands:**
â€¢ /start - Start the bot
â€¢ /help - This help message
â€¢ /profile - View your profile

ğŸ² **Game Types:**
â€¢ **Solo Games**: Slots, Roulette, Blackjack, Crash, Mines, Baccarat, Keno
â€¢ **Duel Games**: 1v1 battles with your friends
â€¢ **Tournaments**: Competitions with big prizes

ğŸ» **Payment System:**
â€¢ Crypto deposit/withdrawal (USDT, TON, BTC, etc.)
â€¢ Instant transaction confirmation
â€¢ VIP membership system
â€¢ Bonuses and promotions

ğŸ† **VIP Advantages:**
â€¢ Higher bet limits
â€¢ Special bonuses
â€¢ Priority support
â€¢ Low commission rates

ğŸ“ **Destek:**
â€¢ 24/7 automatic system
â€¢ Fast response guarantee

ğŸ **Tips:**
â€¢ Don't forget to claim daily bonus
â€¢ With small bets start
â€¢ Earn more as VIP
â€¢ Play responsibly

Good luck! ğŸ€
    """
    
    try:
        keyboard = bot.casino.create_keyboard([
            [("ğŸ® Games", "solo_games"), ("ğŸ» Payment", "payment_menu")],
            [("ğŸ‘‘ Become VIP", "vip_info"), ("ğŸ  Main Menu", "main_menu")]
        ])
        
        await update.message.reply_text(help_text, reply_markup=keyboard, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Help command error: {e}")
        await update.message.reply_text("âŒ Error occurred while sending help message.")

async def support_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Support command handler"""
    support_text = """
ğŸ†˜ **DESTEK MERKEZÄ°**

ğŸ“ **Ä°letiÅŸim:**
â€¢ Telegram: @admin_username
â€¢ Email: support@casino.com

â“ **SÄ±k Sorulan Sorular:**
â€¢ Ã–demeler 24 saat iÃ§inde iÅŸlenir
â€¢ Minimum Ã§ekim miktarÄ± 10 USDT
â€¢ VIP Ã¼yelik otomatik aktif edilir

ğŸ”§ **Teknik Destek:**
â€¢ Bot Ã§alÄ±ÅŸmÄ±yor mu? /start deneyin
â€¢ Ã–deme sorunu? SS gÃ¶nderin
â€¢ Oyun hatasÄ±? Detay verin

â° **Destek Saatleri:**
â€¢ 7/24 Otomatik sistem
â€¢ CanlÄ± destek: 09:00-21:00
    """

    try:
        keyboard = bot.casino.create_keyboard([
            [("ğŸ’¬ CanlÄ± Destek", "contact_support"), ("ğŸ“‹ SSS", "faq")],
            [("ğŸ”™ Ana MenÃ¼", "main_menu")]
        ])

        await update.message.reply_text(support_text, reply_markup=keyboard, parse_mode='Markdown')
    except Exception as e:
        logger.error(f"Support command error: {e}")
        await update.message.reply_text("âŒ Destek mesajÄ± gÃ¶nderilirken hata oluÅŸtu.")

async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Stats command handler"""
    try:
        # Get bot stats
        uptime = datetime.now() - bot.bot_start_time
        uptime_str = f"{uptime.days}g {uptime.seconds//3600}s {(uptime.seconds//60)%60}d"
        
        # Get database stats
        with bot.casino.db.get_connection() as conn:
            total_users = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
            total_games = conn.execute('SELECT COUNT(*) FROM game_results').fetchone()[0]
            total_coins = conn.execute('SELECT SUM(fun_coins) FROM users').fetchone()[0] or 0
            
            # Active users (played in last 24h)
            active_users = conn.execute('''
                SELECT COUNT(DISTINCT user_id) FROM game_results 
                WHERE datetime(created_at) > datetime('now', '-1 day')
            ''').fetchone()[0]
        
        # Payment stats if available
        if bot.payment_manager:
            try:
                with bot.casino.db.get_connection() as conn:
                    total_deposits = conn.execute('SELECT COUNT(*) FROM deposits WHERE status = "paid"').fetchone()[0]
                    total_withdrawals = conn.execute('SELECT COUNT(*) FROM withdrawals WHERE status = "completed"').fetchone()[0]
                    deposit_volume = conn.execute('SELECT SUM(fun_coins) FROM deposits WHERE status = "paid"').fetchone()[0] or 0
                    withdrawal_volume = conn.execute('SELECT SUM(fun_coins) FROM withdrawals WHERE status = "completed"').fetchone()[0] or 0
            except:
                total_deposits = total_withdrawals = deposit_volume = withdrawal_volume = 0
        else:
            total_deposits = total_withdrawals = deposit_volume = withdrawal_volume = 0
        
        stats_text = f"""
ğŸ“Š **BOT STATISTICS** ğŸ“Š

â° **System Status**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸŸ¢ Status: Active and Running
â²ï¸ Uptime: {uptime_str}
ğŸ”„ Ä°ÅŸlenen Komut: {bot.total_commands_processed:,}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ‘¥ **KullanÄ±cÄ± Statisticsi**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸ‘¤ Toplam KullanÄ±cÄ±: {total_users:,}
ğŸ® Active KullanÄ±cÄ± (24s): {active_users:,}
ğŸ² Toplam Oyun: {total_games:,}
ğŸ» Toplam Coin: {total_coins:,} ğŸ»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ’³ **Payment Statisticsi**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸ“¥ Total Deposits: {total_deposits:,}
ğŸ“¤ Total Withdrawals: {total_withdrawals:,}
ğŸ’ YatÄ±rÄ±m Hacmi: {deposit_volume:,} ğŸ»
ğŸ’¸ Ã‡ekim Hacmi: {withdrawal_volume:,} ğŸ»
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ”§ **Sistem Bilgileri**
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
ğŸ Python: {sys.version.split()[0]}
ğŸ’¾ VeritabanÄ±: SQLite
ğŸ” Payment: CryptoBot {'âœ…' if bot.payment_manager else 'âŒ'}
ğŸ¤– Bot Versiyonu: 2.5.1
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        """
        
        keyboard = bot.casino.create_keyboard([
            [("ğŸ“Š Liderlik", "leaderboard"), ("ğŸ† Achievements", "achievements")],
            [("ğŸ» Payment", "payment_menu"), ("ğŸ  Main Menu", "main_menu")]
        ])
        
        await update.message.reply_text(stats_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Stats command error: {e}")
        await update.message.reply_text("âŒ Statistics yÃ¼klenirken error occurred.")

async def show_simple_payment_menu(query, user, casino_bot):
    """Simple payment menu fallback"""
    try:
        text = "ğŸ’³ <b>PAYMENT OPTIONS</b> ğŸ’³\n\n"
        text += "ğŸ”¹ <b>CryptoBot Integration</b>\n"
        text += "â€¢ Fast and secure crypto payments\n"
        text += "â€¢ Automatic Fun Coins credit\n\n"
        text += "ğŸ”¹ <b>Solana Payments</b>\n"
        text += "â€¢ Native SOL deposits/withdrawals\n"
        text += "â€¢ Low transaction fees\n\n"
        text += "ğŸ’ Current Balance: <code>{}</code> FC\n".format(user['fun_coins'] if isinstance(user, dict) else user.get('fun_coins', 0) if hasattr(user, 'get') else 0)

        buttons = [
            [("ğŸ¤– CryptoBot", "cryptobot_menu"), ("ğŸ”® Solana", "solana_payment")],
            [("ğŸ’° Balance", "profile"), ("ğŸ  Main Menu", "main_menu")]
        ]

        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='HTML')

    except Exception as e:
        logger.error(f"Simple payment menu error: {e}")
        await query.edit_message_text(
            "âŒ Payment menu loading error.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def get_group_member_count(bot, chat_id):
    """Get group member count - OPTIMIZED"""
    try:
        return await bot.get_chat_member_count(chat_id)
    except:
        return 1  # Default to 1 if can't get count

def calculate_group_bonus(member_count):
    """Calculate bonus based on group size"""
    if member_count >= 1000:
        return 500  # Large group bonus
    elif member_count >= 500:
        return 300  # Medium group bonus  
    elif member_count >= 100:
        return 200  # Small group bonus
    elif member_count >= 50:
        return 100  # Mini group bonus
    else:
        return 50   # Default bonus

async def get_group_stats(bot, chat_id, casino):
    """Get group gaming statistics - OPTIMIZED"""
    try:
        today = datetime.now().strftime('%Y-%m-%d')
        
        # Single optimized query to get all stats at once
        casino.db.execute("""
            WITH today_games AS (
                SELECT user_id, username, win_amount, won 
                FROM solo_game_history 
                WHERE chat_id = ? AND date(created_at) = ?
            ),
            user_stats AS (
                SELECT username, COUNT(*) as game_count
                FROM today_games 
                GROUP BY user_id 
                ORDER BY game_count DESC 
                LIMIT 1
            )
            SELECT 
                (SELECT COUNT(*) FROM today_games) as games_today,
                (SELECT COALESCE(SUM(win_amount), 0) FROM today_games WHERE won = 1) as winnings_today,
                (SELECT COALESCE(username, 'HenÃ¼z yok') FROM user_stats) as top_player,
                (SELECT COALESCE(game_count, 0) FROM user_stats) as top_player_games
        """, (chat_id, today))
        
        result = casino.db.fetchone()
        
        return {
            'games_today': result[0] or 0,
            'winnings_today': result[1] or 0, 
            'top_player': result[2] or "HenÃ¼z yok",
            'top_player_games': result[3] or 0
        }
    except Exception as e:
        logger.error(f"Group stats error: {e}")
        return {
            'games_today': 0,
            'winnings_today': 0,
            'top_player': "HenÃ¼z yok", 
            'top_player_games': 0
        }

async def slots_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Slots game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_slots", "ğŸ° Slot Machine")
    except Exception as e:
        logger.error(f"Slots command error: {e}")
        await update.message.reply_text("âŒ Slot oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def roulette_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Roulette game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_roulette", "ğŸ”´ Roulette")
    except Exception as e:
        logger.error(f"Roulette command error: {e}")
        await update.message.reply_text("âŒ Roulette oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def blackjack_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Blackjack game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_blackjack", "â™ ï¸ Blackjack")
    except Exception as e:
        logger.error(f"Blackjack command error: {e}")
        await update.message.reply_text("âŒ Blackjack oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def crash_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Crash game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_crash", "ğŸš€ Crash")
    except Exception as e:
        logger.error(f"Crash command error: {e}")
        await update.message.reply_text("âŒ Crash oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def mines_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mines game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_mines", "â›ï¸ Mines")
    except Exception as e:
        logger.error(f"Mines command error: {e}")
        await update.message.reply_text("âŒ Mines oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def baccarat_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Baccarat game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_baccarat", "ğŸƒ Baccarat")
    except Exception as e:
        logger.error(f"Baccarat command error: {e}")
        await update.message.reply_text("âŒ Baccarat oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def keno_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Keno game command handler"""
    try:
        await handle_solo_game_menu_command(update, "solo_keno", "ğŸ¯ Keno")
    except Exception as e:
        logger.error(f"Keno command error: {e}")
        await update.message.reply_text("âŒ Keno oyunu baÅŸlatÄ±lÄ±rken hata oluÅŸtu.")

async def handle_solo_game_menu_command(update: Update, game_type: str, game_name: str):
    """Handle solo game menu for command shortcuts"""
    user = await get_or_create_user(update.effective_user)
    if not user:
        await update.message.reply_text("âŒ KullanÄ±cÄ± bilgileri alÄ±namadÄ±!")
        return

    text = f"""
{game_name}

ğŸ¯ **Bahis MiktarÄ± SeÃ§in:**

ğŸ’° **Mevcut Bakiye:** {user['fun_coins']:,} Coins
ğŸ® **Oyun:** {game_name}
âš¡ **HÄ±zlÄ± Oyna:** Bahis seÃ§ip oynayÄ±n!
    """

    buttons = [
        [("ğŸ’° 10", f"solo_bet_{game_type}_10"), ("ğŸ’° 50", f"solo_bet_{game_type}_50")],
        [("ğŸ’° 100", f"solo_bet_{game_type}_100"), ("ğŸ’° 500", f"solo_bet_{game_type}_500")],
        [("ğŸ’° 1K", f"solo_bet_{game_type}_1000"), ("ğŸ’° 5K", f"solo_bet_{game_type}_5000")],
        [("ğŸ® Oyunlar", "solo_games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
    ]

    keyboard = bot.casino.create_keyboard(buttons)
    await update.message.reply_text(text, reply_markup=keyboard, parse_mode='Markdown')

async def game_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Game command handler - Only works in groups"""
    try:
        # Check if this is a group chat
        if not is_group_chat(update):
            await update.message.reply_text(
                "ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!\n\n"
                "ğŸ’¡ Ã–zel mesajda oyun oynamak iÃ§in bot ile direkt konuÅŸun ve /start yazÄ±n.",
                parse_mode='Markdown'
            )
            return
            
        user_id = update.effective_user.id
        username = update.effective_user.username or "Anonymous"
        
        # Get or create user
        user = bot.casino.get_user(user_id, username)
        
        # Calculate group bonus
        chat_id = update.effective_chat.id
        group_members = await get_group_member_count(context.bot, chat_id)
        group_bonus = calculate_group_bonus(group_members)
        
        # Apply group bonus if eligible
        bonus_applied = False
        if group_bonus > 0:
            # Check if user already got bonus today
            today = datetime.now().strftime('%Y-%m-%d')
            bonus_key = f"group_bonus_{chat_id}_{user_id}_{today}"
            
            try:
                # Check if bonus already given today
                bot.casino.db.execute(
                    "SELECT id FROM user_bonuses WHERE user_id = ? AND bonus_type = ? AND date(created_at) = date('now')",
                    (user_id, f"group_bonus_{chat_id}")
                )
                if not bot.casino.db.fetchone():
                    # Give group bonus
                    bot.casino.db.execute(
                        "UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?",
                        (group_bonus, user_id)
                    )
                    bot.casino.db.execute(
                        "INSERT INTO user_bonuses (user_id, bonus_type, amount, created_at) VALUES (?, ?, ?, datetime('now'))",
                        (user_id, f"group_bonus_{chat_id}", group_bonus)
                    )
                    bot.casino.db.commit()
                    bonus_applied = True
                    user = bot.casino.get_user(user_id, username)  # Refresh user data
            except:
                pass  # Ignore bonus errors
        
        # Get group statistics
        group_stats = await get_group_stats(context.bot, chat_id, bot.casino)
        
        # Create enhanced solo games menu for groups
        bonus_text = ""
        if bonus_applied:
            bonus_text = f"ğŸ **GRUP BONUSU ALDIN!** +{group_bonus:,} ğŸ»\n\n"
        elif group_bonus > 0:
            bonus_text = f"ğŸ **Grup Bonusu:** {group_bonus:,} ğŸ» (gÃ¼nlÃ¼k)\n\n"
        
        games_text = f"""
ğŸ® **GRUP SOLO OYUN MENÃœSÃœ** ğŸ®

ğŸ‘‹ Hello {username}! Welcome to group solo gaming!

{bonus_text}ğŸ“Š **GROUP STATISTICS (Today):**
ğŸ¯ **Games Played:** {group_stats['games_today']} games
ğŸ’° **Total Winnings:** {group_stats['winnings_today']:,} ğŸ»
ğŸ‘‘ **Most Active:** {group_stats['top_player']} ({group_stats['top_player_games']} games)
ğŸ‘¥ **Member Count:** {group_members} members

ğŸ¯ **Classic Casino Games (4 games):**
â€¢ ğŸ° **Slot Machine** - 3 reel luck!
â€¢ ğŸ”´ **Roulette** - Red or black?
â€¢ â™ ï¸ **Blackjack** - 21'e yaklaÅŸ!
â€¢ ğŸƒ **Baccarat** - Banker vs Player!

ğŸš€ **Modern Oyunlar (3 oyun):**
â€¢ ğŸš€ **Crash** - Roket kaÃ§madan Ã§Ä±k!
â€¢ â›ï¸ **Mines** - MayÄ±nlarÄ± sakÄ±n!
â€¢ ğŸ¯ **Keno** - SayÄ±larÄ± tahmin et!

ğŸ² **Telegram Dice OyunlarÄ± (6 oyun):**
â€¢ ğŸ² **Klasik Zar** - 1-6 arasÄ± gerÃ§ek zar!
â€¢ ğŸ¯ **Dart** - Bullseye vur! (x10)
â€¢ ğŸ€ **Basketbol** - Basket at! (x5)
â€¢ âš½ **Futbol** - Gol vur! (x5)
â€¢ ğŸ³ **Bowling** - Strike! (x6)
â€¢ ğŸ° **Dice Slot** - 64 kombinasyon!

ğŸª **EÄŸlence OyunlarÄ± (4 oyun):**
â€¢ ğŸª **Lucky Wheel** - Åans Ã§arkÄ±!
â€¢ ğŸ² **Solo Zar** - Basit zar oyunu!
â€¢ âœ‚ï¸ **TaÅŸ-KaÄŸÄ±t-Makas** - Klasik!
â€¢ ğŸ”¢ **SayÄ± Tahmin** - 1-100 arasÄ±!

ğŸ’° **Bakiyeniz:** {user['fun_coins']:,} ğŸ»
ğŸ® **Oyun SayÄ±nÄ±z:** {user['games_count'] if 'games_count' in user.keys() else 0}

âš ï¸ **NOT:** TÃ¼m oyunlar 100ğŸ» sabit bahisle oynanÄ±r.
ğŸ”¥ **Big wins are announced to the group!**
        """
        
        # Create complete game selection keyboard for groups - 6 GAMES
        from telegram import InlineKeyboardButton, InlineKeyboardMarkup
        
        keyboard_buttons = [
            # Telegram Dice Games (6 games)
            [InlineKeyboardButton("ğŸ° Dice Slot (100ğŸ»)", callback_data="group_dice_slot_100"),
             InlineKeyboardButton("âš½ Futbol (100ğŸ»)", callback_data="group_dice_football_100")],
            [InlineKeyboardButton("ğŸ³ Bowling (100ğŸ»)", callback_data="group_dice_bowling_100")],
            [InlineKeyboardButton("ğŸ² Klasik Zar (100ğŸ»)", callback_data="group_dice_classic_100"),
             InlineKeyboardButton("ğŸ¯ Dart (100ğŸ»)", callback_data="group_dice_darts_100")],
            [InlineKeyboardButton("ğŸ€ Basketbol (100ğŸ»)", callback_data="group_dice_basketball_100")],
            # Menu Options
            [InlineKeyboardButton("ğŸ“Š Grup Ä°statistikleri", callback_data="group_stats"),
             InlineKeyboardButton("ğŸ‘¤ Profilim", callback_data="my_stats")],
            [InlineKeyboardButton("ğŸ’¬ Bot ile Ã–zel Oyna", url=f"https://t.me/{context.bot.username}?start=fullgames")]
        ]
        keyboard = InlineKeyboardMarkup(keyboard_buttons)
        
        await update.message.reply_text(games_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Game command error: {e}")
        await update.message.reply_text("âŒ Oyun menÃ¼sÃ¼ yÃ¼klenirken hata oluÅŸtu.")

async def games_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Games command handler - Full games menu (private chats)"""
    try:
        user_id = update.effective_user.id
        username = update.effective_user.username or "Anonymous"
        
        # Get or create user
        user = bot.casino.get_user(user_id, username)
        
        # Create games menu with fun emojis
        games_text = f"""
ğŸ® **SOLO GAMES MENU** ğŸ®

ğŸ‘‹ Hey {username}! Bireysel oyunlar menÃ¼sÃ¼ne hoÅŸ geldin!

ğŸ¯ **HÄ±zlÄ± Oyunlar:**
â€¢ ğŸ° **Slot Machine** - ÅansÄ±nÄ± dene!
â€¢ ğŸ”´ **Roulette** - Red or black?
â€¢ â™ ï¸ **Blackjack** - 21'e yakÄ±n!
â€¢ ğŸš€ **Crash** - Rocket game!

ğŸ§  **Zeka OyunlarÄ±:**
â€¢ â›ï¸ **Mines** - MayÄ±nlarÄ± bul!
â€¢ ğŸ² **Dice** - ZarlarÄ± at!
â€¢ ğŸƒ **Baccarat** - Kart oyunu!
â€¢ ğŸ¯ **Keno** - SayÄ± tahmin et!

ğŸ†• **Yeni Eklenen:**
â€¢ âœ‚ï¸ **TaÅŸ-KaÄŸÄ±t-Makas** - Klasik!
â€¢ ğŸ”¢ **SayÄ± Tahmin** - 1-100 arasÄ±!
â€¢ ğŸª **Lucky Wheel** - DÃ¶ndÃ¼r kazÄ±n!

ğŸ’° **Bakiyeniz:** {user['fun_coins']:,} ğŸ»
ğŸ® **Oyun SayÄ±nÄ±z:** {user['games_count'] if 'games_count' in user.keys() else 0}

Hangi oyunu oynamak istiyorsun?
        """
        
        # Create game selection keyboard
        keyboard = bot.casino.create_keyboard([
            [("ğŸ° Slot", "play_solo_slot"), ("ğŸ”´ Roulette", "play_solo_roulette")],
            [("â™ ï¸ Blackjack", "play_solo_blackjack"), ("ğŸš€ Crash", "play_solo_crash")],
            [("â›ï¸ Mines", "play_solo_mines"), ("ğŸƒ Baccarat", "play_solo_baccarat")],
            [("ğŸ¯ Keno", "play_solo_keno"), ("ğŸ² Dice", "play_solo_dice")],
            [("âœ‚ï¸ TaÅŸ-KaÄŸÄ±t-Makas", "play_rock_paper_scissors"), ("ğŸ”¢ SayÄ± Tahmin", "play_number_guess")],
            [("ğŸª Lucky Wheel", "play_lucky_wheel"), ("ğŸ“Š Ä°statistikler", "my_stats")],
            [("ğŸ  Ana MenÃ¼", "main_menu")]
        ])
        
        await update.message.reply_text(games_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Games command error: {e}")
        await update.message.reply_text("âŒ Oyunlar menÃ¼sÃ¼ yÃ¼klenirken hata oluÅŸtu.")


# GROUP-ONLY SLASH COMMANDS FOR DICE GAMES
async def diceslots_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Dice Slots command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "slot_machine", "ğŸ° Dice Slots")

async def dartgame_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Dart Game command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "darts", "ğŸ¯ Dart Game")

async def classicdice_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Classic Dice command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "classic_dice", "ğŸ² Classic Dice")

async def basketball_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Basketball command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "basketball", "ğŸ€ Basketball")

async def football_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Football command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "football", "âš½ Football")

async def bowling_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Bowling command - Group only"""
    if not is_group_chat(update):
        await update.message.reply_text("ğŸš« Bu komut sadece grup chatlerinde kullanÄ±labilir!")
        return
    await play_group_dice_game(update, context, "bowling", "ğŸ³ Bowling")

# Additional command wrappers for private chat features
async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Profile command - redirects to main menu profile section"""
    await start_command(update, context)

async def balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Balance command - redirects to main menu"""
    await start_command(update, context)

async def daily_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Daily bonus command - redirects to main menu"""
    await start_command(update, context)

async def spinner_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Daily spinner command - redirects to main menu"""
    await start_command(update, context)

async def deposit_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Deposit command - redirects to main menu"""
    await start_command(update, context)

async def withdraw_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Withdraw command - redirects to main menu"""
    await start_command(update, context)

async def achievements_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Achievements command - redirects to main menu"""
    await start_command(update, context)

async def friends_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Friends command - redirects to main menu"""
    await start_command(update, context)

async def leaderboard_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Leaderboard command - redirects to main menu"""
    await start_command(update, context)

async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Settings command - redirects to main menu"""
    await start_command(update, context)

async def play_group_dice_game(update: Update, context: ContextTypes.DEFAULT_TYPE, dice_type: str, game_name: str):
    """Play a dice game directly in group with 100 coins bet"""
    try:
        user_id = update.effective_user.id
        username = update.effective_user.username or "Anonymous"

        # Get user data
        user = bot.casino.get_user(user_id, username)

        # Check balance (100 coins fixed bet)
        bet_amount = 100
        if user['fun_coins'] < bet_amount:
            await update.message.reply_text(
                f"ğŸ’¸ Yetersiz bakiye!\n\n"
                f"{game_name} oynamak iÃ§in {bet_amount} ğŸ» gerekli.\n"
                f"ğŸ» **Bakiyeniz:** {user['fun_coins']} ğŸ»\n\n"
                f"ğŸ’¡ /start ile gÃ¼nlÃ¼k bonus alabilirsiniz!"
            )
            return

        # Import dice games handler
        from dice_games import get_dice_games_instance
        dice_games = get_dice_games_instance(bot.casino)

        # Create a mock query object for dice game handler
        class MockQuery:
            def __init__(self, message):
                self.message = message
                self.from_user = message.from_user

            async def edit_message_text(self, text, **kwargs):
                await self.message.reply_text(text, **kwargs)

        mock_query = MockQuery(update.message)

        # Play the dice game
        await dice_games.play_dice_game(mock_query, user, dice_type, bet_amount)

    except Exception as e:
        logger.error(f"Group dice game error ({dice_type}): {e}")
        await update.message.reply_text(f"âŒ {game_name} oynanÄ±rken hata oluÅŸtu!")

async def handle_custom_sol_amount_input(update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, user):
    """Handle custom SOL amount input from user"""
    try:
        # Clear the waiting flag
        context.user_data['waiting_for_custom_sol_amount'] = False

        # Try to parse the SOL amount
        try:
            # Replace comma with dot if user used comma
            text = text.replace(',', '.')
            sol_amount = float(text)

            # Validate amount
            if sol_amount < 0.01:
                await update.message.reply_text(
                    "âŒ **Minimum miktar hatasÄ±!**\n\n"
                    "ğŸ’° **Minimum:** 0.01 SOL\n"
                    "ğŸ“ **GirdiÄŸiniz:** {:.4f} SOL\n\n"
                    "ğŸ’¡ LÃ¼tfen minimum 0.01 SOL girin.".format(sol_amount),
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ’ Tekrar Dene", "deposit_sol_custom")],
                        [("ğŸ”™ Geri", "solana_deposit"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                    ]),
                    parse_mode='Markdown'
                )
                return

            if sol_amount > 100:
                await update.message.reply_text(
                    "âŒ **Maksimum miktar hatasÄ±!**\n\n"
                    "ğŸ’° **Maksimum:** 100 SOL\n"
                    "ğŸ“ **GirdiÄŸiniz:** {:.4f} SOL\n\n"
                    "ğŸ’¡ LÃ¼tfen maksimum 100 SOL girin.".format(sol_amount),
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ’ Tekrar Dene", "deposit_sol_custom")],
                        [("ğŸ”™ Geri", "solana_deposit"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                    ]),
                    parse_mode='Markdown'
                )
                return

            # Valid amount - show confirmation
            from solana_handlers import show_sol_amount_confirmation

            # Create a fake query object for compatibility
            class FakeQuery:
                def __init__(self, message):
                    self.message = message
                    self.from_user = message.from_user

                async def edit_message_text(self, text, reply_markup=None, parse_mode=None):
                    # Send new message instead of editing
                    await self.message.reply_text(text, reply_markup=reply_markup, parse_mode=parse_mode)

                async def answer(self, text="", show_alert=False):
                    pass

            fake_query = FakeQuery(update.message)
            await show_sol_amount_confirmation(fake_query, user, sol_amount, bot.casino)

        except ValueError:
            await update.message.reply_text(
                "âŒ **GeÃ§ersiz format!**\n\n"
                "ğŸ’¡ **DoÄŸru format Ã¶rnekleri:**\n"
                "â€¢ 0.5 (yarÄ±m SOL)\n"
                "â€¢ 1.25 (bir buÃ§uk SOL)\n"
                "â€¢ 2.75 (iki Ã¼Ã§te dÃ¶rt SOL)\n\n"
                "âš ï¸ **Dikkat:**\n"
                "â€¢ Sadece sayÄ± girin\n"
                "â€¢ Nokta kullanÄ±n (virgÃ¼l deÄŸil)\n"
                "â€¢ SOL yazmayÄ±n",
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ’ Tekrar Dene", "deposit_sol_custom")],
                    [("ğŸ”™ Geri", "solana_deposit"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ]),
                parse_mode='Markdown'
            )

    except Exception as e:
        logger.error(f"Custom SOL amount input error: {e}")
        await update.message.reply_text(
            "âŒ Ä°ÅŸlem sÄ±rasÄ±nda hata oluÅŸtu.\n\n"
            "LÃ¼tfen tekrar deneyin veya Ã¶nceden tanÄ±mlanmÄ±ÅŸ miktarlarÄ± kullanÄ±n.",
            reply_markup=bot.casino.create_keyboard([
                [("ğŸ”™ Geri", "solana_deposit"), ("ğŸ  Ana MenÃ¼", "main_menu")]
            ])
        )

async def handle_custom_withdrawal_amount_input(update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, user):
    """Handle custom withdrawal SOL amount input from user"""
    try:
        # Clear the waiting flag
        context.user_data['waiting_for_custom_withdrawal_amount'] = False

        # Try to parse the SOL amount
        try:
            # Replace comma with dot if user used comma
            text = text.replace(',', '.')
            sol_amount = float(text)

            # Get current rate and calculate max withdrawal
            from solana_payment import get_solana_payment
            solana_system = get_solana_payment()
            current_rate = solana_system.get_sol_to_fc_rate()
            user_balance = user['fun_coins']
            max_sol = user_balance / current_rate

            # Validate amount
            if sol_amount < 0.01:
                await update.message.reply_text(
                    "âŒ **Minimum miktar hatasÄ±!**\n\n"
                    "ğŸ’° **Minimum:** 0.01 SOL\n"
                    "ğŸ“ **GirdiÄŸiniz:** {:.4f} SOL\n\n"
                    "ğŸ’¡ LÃ¼tfen minimum 0.01 SOL girin.".format(sol_amount),
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ’ Tekrar Dene", "withdraw_sol_custom")],
                        [("ğŸ”™ Geri", "solana_withdraw"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                    ]),
                    parse_mode='Markdown'
                )
                return

            if sol_amount > max_sol:
                await update.message.reply_text(
                    "âŒ **Yetersiz bakiye!**\n\n"
                    "ğŸ’° **Maksimum Ã§ekim:** {:.4f} SOL\n"
                    "ğŸ’¸ **Mevcut bakiye:** {:.0f} FC\n"
                    "ğŸ“ **GirdiÄŸiniz:** {:.4f} SOL\n\n"
                    "ğŸ’¡ Bakiyenizden fazla Ã§ekemezsiniz.".format(max_sol, user_balance, sol_amount),
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ’ Tekrar Dene", "withdraw_sol_custom")],
                        [("ğŸ’° Bakiye YÃ¼kle", "solana_deposit")],
                        [("ğŸ”™ Geri", "solana_withdraw"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                    ]),
                    parse_mode='Markdown'
                )
                return

            # Valid amount - show wallet input
            from solana_handlers import show_withdrawal_wallet_input

            # Create a fake query object for compatibility
            class FakeQuery:
                def __init__(self, message):
                    self.message = message
                    self.from_user = message.from_user

                async def edit_message_text(self, text, reply_markup=None, parse_mode=None):
                    # Send new message instead of editing
                    await self.message.reply_text(text, reply_markup=reply_markup, parse_mode=parse_mode)

                async def answer(self, text="", show_alert=False):
                    pass

            fake_query = FakeQuery(update.message)
            await show_withdrawal_wallet_input(fake_query, user, sol_amount, bot.casino)

        except ValueError:
            await update.message.reply_text(
                "âŒ **GeÃ§ersiz format!**\n\n"
                "ğŸ’¡ **DoÄŸru format Ã¶rnekleri:**\n"
                "â€¢ 0.5 (yarÄ±m SOL)\n"
                "â€¢ 1.25 (bir buÃ§uk SOL)\n"
                "â€¢ 2.75 (iki Ã¼Ã§te dÃ¶rt SOL)\n\n"
                "âš ï¸ **Dikkat:**\n"
                "â€¢ Sadece sayÄ± girin\n"
                "â€¢ Nokta kullanÄ±n (virgÃ¼l deÄŸil)\n"
                "â€¢ SOL yazmayÄ±n",
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ’ Tekrar Dene", "withdraw_sol_custom")],
                    [("ğŸ”™ Geri", "solana_withdraw"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ]),
                parse_mode='Markdown'
            )

    except Exception as e:
        logger.error(f"Custom withdrawal amount input error: {e}")
        await update.message.reply_text(
            "âŒ Ä°ÅŸlem sÄ±rasÄ±nda hata oluÅŸtu.\n\n"
            "LÃ¼tfen tekrar deneyin veya Ã¶nceden tanÄ±mlanmÄ±ÅŸ miktarlarÄ± kullanÄ±n.",
            reply_markup=bot.casino.create_keyboard([
                [("ğŸ”™ Geri", "solana_withdraw"), ("ğŸ  Ana MenÃ¼", "main_menu")]
            ])
        )

async def handle_text_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle text messages (like friend codes and wallet addresses)"""
    try:
        user_id = update.effective_user.id
        username = update.effective_user.username
        text = update.message.text.strip()

        # Get user data
        user = bot.casino.get_user(user_id, username)

        # Check if user is waiting for wallet address input
        if context.user_data.get('waiting_for_withdrawal_address'):
            from solana_flow_completion import handle_withdrawal_address_input
            await handle_withdrawal_address_input(update, context, text)
            return

        # Check if user is waiting for custom SOL amount input
        if context.user_data.get('waiting_for_custom_sol_amount'):
            await handle_custom_sol_amount_input(update, context, text, user)
            return

        # Check if user is waiting for custom withdrawal amount input
        if context.user_data.get('waiting_for_custom_withdrawal_amount'):
            await handle_custom_withdrawal_amount_input(update, context, text, user)
            return

        # Check if text looks like a friend code (6 characters, alphanumeric)
        # Auto-convert to uppercase for easier user experience
        if len(text) == 6 and text.isalnum():
            friend_code = text.upper()
            result = bot.casino.add_friend_by_code(user_id, friend_code)
            
            if result['success']:
                await update.message.reply_text(
                    f"âœ… {result['message']}\n\n"
                    "ğŸ“¬ ArkadaÅŸlÄ±k isteÄŸi gÃ¶nderildi!\n"
                    "ğŸ‘¥ Kabul edildiÄŸinde arkadaÅŸ listenizde gÃ¶rÃ¼necek.",
                    reply_markup=bot.casino.create_keyboard([
                        [("ğŸ‘¥ ArkadaÅŸlarÄ±m", "friends"), ("ğŸ“¬ Ä°stekler", "friend_requests")],
                        [("ğŸ  Main Menu", "main_menu")]
                    ])
                )
            else:
                await update.message.reply_text(
                    f"âŒ {result['message']}\n\n"
                    "ğŸ’¡ **Tips:**\n"
                    "â€¢ 6 haneli kod olmalÄ± (Ã¶rn: ABC123)\n"
                    "â€¢ BÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf Ã¶nemli deÄŸil\n"
                    "â€¢ GeÃ§erli bir arkadaÅŸ kodu olmalÄ±",
                    reply_markup=bot.casino.create_keyboard([
                        [("â• ArkadaÅŸ Ekle", "add_friend")],
                        [("ğŸ  Main Menu", "main_menu")]
                    ])
                )
        else:
            # Not a friend code, ignore or provide help
            await update.message.reply_text(
                "ğŸ¤” AnlayamadÄ±m!\n\n"
                "ğŸ’¡ **Yapabilecekleriniz:**\n"
                "â€¢ 6 haneli arkadaÅŸ kodu girin (Ã¶rn: ABC123)\n"
                "â€¢ /start - Start the botÄ±n\n"
                "â€¢ /help - YardÄ±m alÄ±n",
                reply_markup=bot.casino.create_keyboard([
                    [("ğŸ® Oyuna BaÅŸla", "main_menu")],
                    [("â“ YardÄ±m", "help")]
                ])
            )
            
    except Exception as e:
        logger.error(f"Text message handler error: {e}")
        await update.message.reply_text(
            "âŒ MesajÄ±nÄ±z iÅŸlenirken error occurred!\n"
            "ğŸ”„ LÃ¼tfen tekrar deneyin veya /start yazÄ±n."
        )

async def handle_my_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle bot added/removed from groups"""
    try:
        result = update.my_chat_member
        chat = update.effective_chat
        user = update.effective_user
        
        old_status = result.old_chat_member.status
        new_status = result.new_chat_member.status
        
        logger.info(f"Bot status change in chat {chat.id} ({chat.title}): {old_status} -> {new_status}")
        
        # Bot was added to a group/channel
        if old_status in ['left', 'kicked'] and new_status in ['member', 'administrator']:
            if chat.type in ['group', 'supergroup']:
                # Send welcome message to the group
                welcome_text = f"""
ğŸ° **Casino Bot'a HoÅŸ Geldiniz!** ğŸ°

Hello! I'm a casino bot and I've been added to your group! ğŸ‰

ğŸ® **What I can do:**
â€¢ Slot machines, roulette and more casino games
â€¢ Multiplayer duels and tournaments
â€¢ Daily bonuses and VIP system
â€¢ Secure crypto payments
â€¢ Friends system and leaderboard

ğŸš€ **To get started:**
â€¢ Start private chat with bot: /start
â€¢ OyunlarÄ± gÃ¶rÃ¼ntÃ¼lemek iÃ§in burada /start yazÄ±n
â€¢ Grup Ã¼yeleriniz de bot ile oynayabilir!

âš¡ **HÄ±zlÄ± baÅŸlangÄ±Ã§:** /start komutu ile oyuna baÅŸlayÄ±n!

ğŸ“ Not: Bot'un Ã§alÄ±ÅŸmasÄ± iÃ§in bot ile Ã¶zel mesajlaÅŸma baÅŸlatmanÄ±z gerekir.
                """
                
                keyboard = bot.casino.create_keyboard([
                    [("ğŸ® Oyuna BaÅŸla", f"https://t.me/{context.bot.username}?start=group")],
                    [("ğŸ“Š Bot HakkÄ±nda", "about_bot")]
                ])
                
                try:
                    await context.bot.send_message(
                        chat_id=chat.id,
                        text=welcome_text,
                        reply_markup=keyboard,
                        parse_mode='Markdown'
                    )
                    logger.info(f"Welcome message sent to group {chat.title} ({chat.id})")
                except Exception as e:
                    logger.error(f"Failed to send welcome message to group {chat.id}: {e}")
        
        # Bot was removed from group
        elif old_status in ['member', 'administrator'] and new_status in ['left', 'kicked']:
            logger.info(f"Bot removed from group {chat.title} ({chat.id}) by user {user.username if user else 'Unknown'}")
            
    except Exception as e:
        logger.error(f"Error handling my_chat_member update: {e}")

async def handle_chat_member(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle user join/leave events in groups where bot is present"""
    try:
        result = update.chat_member
        chat = update.effective_chat
        user = result.from_user
        
        old_status = result.old_chat_member.status
        new_status = result.new_chat_member.status
        
        # User joined the group
        if old_status in ['left', 'kicked'] and new_status in ['member', 'administrator', 'creator']:
            if chat.type in ['group', 'supergroup']:
                welcome_text = f"""ğŸ‘‹ HoÅŸ geldin {user.first_name}!

ğŸ° Bu grupta Casino Bot var!
Bot ile oynayarak eÄŸlenebilir ve Ã¶dÃ¼ller kazanabilirsin!

ğŸ® Oyuna baÅŸlamak iÃ§in:
â€¢ Bot ile Ã¶zel mesaj baÅŸlat: @{context.bot.username}
â€¢ Veya buraya /start yaz

ğŸ Ä°lk kez katÄ±ldÄ±ÄŸÄ±n iÃ§in bonus kazanabilirsin!"""
                
                keyboard = bot.casino.create_keyboard([
                    [("ğŸ® Bot ile Oyna", f"https://t.me/{context.bot.username}?start=welcome")]
                ])

                try:
                    await context.bot.send_message(
                        chat_id=chat.id,
                        text=welcome_text,
                        reply_markup=keyboard,
                        parse_mode=None
                    )
                except Exception as e:
                    logger.error(f"Failed to send user welcome message: {e}")
        
    except Exception as e:
        logger.error(f"Error handling chat_member update: {e}")

async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Global error handler"""
    logger.error(f"Exception while handling an update: {context.error}")
    
    try:
        if update and update.effective_message:
            await update.effective_message.reply_text(
                "âŒ Beklenmeyen bir error occurred!\n\n"
                "ğŸ”„ LÃ¼tfen /start komutu ile botunu yeniden baÅŸlatÄ±n."
            )
    except Exception as e:
        logger.error(f"Error in error handler: {e}")

def check_instance():
    """Check if another bot instance is already running"""
    pid_file = "casino_bot.pid"
    
    if os.path.exists(pid_file):
        try:
            with open(pid_file, 'r') as f:
                old_pid = int(f.read().strip())
            
            # Check if process is still running on Windows
            try:
                import subprocess
                result = subprocess.run(['tasklist', '/FI', f'PID eq {old_pid}'], 
                                      capture_output=True, text=True, shell=True)
                if str(old_pid) in result.stdout:
                    logger.error(f"Another bot instance is already running with PID {old_pid}")
                    logger.error("Please stop the other instance before starting a new one")
                    sys.exit(1)
                else:
                    # Process not running, remove stale PID file
                    os.remove(pid_file)
            except Exception:
                # If we can't check, remove the PID file and continue
                os.remove(pid_file)
        except (ValueError, FileNotFoundError):
            # Invalid or missing PID file, remove it
            if os.path.exists(pid_file):
                os.remove(pid_file)
    
    # Write current PID
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))
    
    return pid_file

def cleanup_pid_file(pid_file):
    """Remove PID file on exit"""
    try:
        if os.path.exists(pid_file):
            os.remove(pid_file)
    except Exception as e:
        logger.warning(f"Could not remove PID file: {e}")

async def setup_bot_commands(bot):
    """Setup bot commands with different visibility for groups vs private chats"""
    try:
        from telegram import BotCommand, BotCommandScopeAllPrivateChats, BotCommandScopeAllGroupChats

        # Commands for private chats (DM) - kiÅŸisel Ã¶zellikler
        private_commands = [
            BotCommand("start", "ğŸš€ Botu baÅŸlat"),
            BotCommand("help", "â“ YardÄ±m menÃ¼sÃ¼"),
            BotCommand("support", "ğŸ†˜ Destek al"),
            BotCommand("stats", "ğŸ“Š Ä°statistiklerim"),
            BotCommand("games", "ğŸ® Oyunlar menÃ¼sÃ¼"),
            BotCommand("profile", "ğŸ‘¤ Profilim"),
            BotCommand("balance", "ğŸ’° Bakiyem"),
            BotCommand("daily", "ğŸ GÃ¼nlÃ¼k bonus"),
            BotCommand("spinner", "ğŸ¡ GÃ¼nlÃ¼k Ã§ark"),
            BotCommand("deposit", "ğŸ’³ Para yatÄ±r"),
            BotCommand("withdraw", "ğŸ’¸ Para Ã§ek"),
            BotCommand("achievements", "ğŸ† BaÅŸarÄ±larÄ±m"),
            BotCommand("friends", "ğŸ‘¥ ArkadaÅŸlarÄ±m"),
            BotCommand("leaderboard", "ğŸ¥‡ Liderlik tablosu"),
            BotCommand("settings", "âš™ï¸ Ayarlar")
        ]

        # Commands for group chats - sadece support ve dice oyunlarÄ±
        group_commands = [
            BotCommand("support", "ğŸ†˜ Destek al"),
            BotCommand("diceslots", "ğŸ² Dice Slots"),
            BotCommand("dartgame", "ğŸ¯ Dart Game"),
            BotCommand("classicdice", "ğŸ² Classic Dice"),
            BotCommand("basketball", "ğŸ€ Basketball"),
            BotCommand("football", "âš½ Football"),
            BotCommand("bowling", "ğŸ³ Bowling")
        ]

        # Set commands for private chats
        # await bot.set_my_commands(private_commands, scope=BotCommandScopeAllPrivateChats())
        # logger.info("SUCCESS: Private chat commands set (no /game)")

        # Set commands for group chats
        # await bot.set_my_commands(group_commands, scope=BotCommandScopeAllGroupChats())
        # logger.info("SUCCESS: Group chat commands set (with /game)")

        # Clear all commands temporarily
        await bot.set_my_commands([])
        logger.info("SUCCESS: All commands cleared")

    except Exception as e:
        logger.error(f"ERROR: Failed to setup bot commands: {e}")

async def run_main_bot():
    """Async function to run the bot properly"""
    try:
        # Create HTTPx request with proper configuration
        from telegram.request import HTTPXRequest
        request = HTTPXRequest(
            connection_pool_size=512,
            read_timeout=30,
            write_timeout=30,
            connect_timeout=60,
            pool_timeout=30,
            http_version="1.1"
        )

        application = Application.builder().token(BOT_TOKEN).request(request).build()

        # Add handlers - All available commands
        application.add_handler(CommandHandler("start", start_command))
        application.add_handler(CommandHandler("help", help_command))
        application.add_handler(CommandHandler("support", support_command))
        application.add_handler(CommandHandler("games", games_command))
        application.add_handler(CommandHandler("slots", slots_command))
        application.add_handler(CommandHandler("roulette", roulette_command))
        application.add_handler(CommandHandler("blackjack", blackjack_command))
        application.add_handler(CommandHandler("crash", crash_command))
        application.add_handler(CommandHandler("mines", mines_command))
        application.add_handler(CommandHandler("baccarat", baccarat_command))
        application.add_handler(CommandHandler("keno", keno_command))
        application.add_handler(CommandHandler("diceslots", diceslots_command))
        application.add_handler(CommandHandler("dartgame", dartgame_command))
        application.add_handler(CommandHandler("classicdice", classicdice_command))
        application.add_handler(CommandHandler("basketball", basketball_command))
        application.add_handler(CommandHandler("football", football_command))
        application.add_handler(CommandHandler("bowling", bowling_command))
        application.add_handler(CommandHandler("profile", profile_command))
        application.add_handler(CommandHandler("balance", balance_command))
        application.add_handler(CommandHandler("daily", daily_command))
        application.add_handler(CommandHandler("spinner", spinner_command))
        application.add_handler(CommandHandler("deposit", deposit_command))
        application.add_handler(CommandHandler("withdraw", withdraw_command))
        application.add_handler(CommandHandler("achievements", achievements_command))
        application.add_handler(CommandHandler("friends", friends_command))
        application.add_handler(CommandHandler("leaderboard", leaderboard_command))
        application.add_handler(CommandHandler("settings", settings_command))
        application.add_handler(CallbackQueryHandler(button_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))

        # Add group event handlers for automatic bot startup
        from telegram.ext import ChatMemberHandler
        application.add_handler(ChatMemberHandler(handle_my_chat_member, ChatMemberHandler.MY_CHAT_MEMBER))
        application.add_handler(ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER))

        # Add error handler
        application.add_error_handler(error_handler)

        # Start the bot with proper polling
        await application.run_polling(drop_pending_updates=True)
    except Exception as e:
        logger.error(f"Bot run error: {e}")
        raise

def main():
    """Main function to run the bot with robust error handling"""
    global bot

    # Ensure we start with a clean event loop
    import asyncio
    try:
        # Close any existing event loop that might be corrupted
        try:
            current_loop = asyncio.get_running_loop()
            if current_loop and not current_loop.is_closed():
                current_loop.close()
        except RuntimeError:
            pass  # No running loop, which is what we want

        # Create a fresh event loop for the entire application
        try:
            loop = asyncio.get_running_loop()
        except RuntimeError:
            # No running loop, create a new one
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
    except Exception as e:
        print(f"Warning: Could not set up fresh event loop: {e}")

    # Check for running instances
    pid_file = check_instance()
    
    try:
        # Initialize enhanced bot with network error handling
        max_init_retries = 3
        init_delay = 2
        
        for init_attempt in range(max_init_retries):
            try:
                bot = EnhancedCasinoBot()
                logger.info("Enhanced Casino Bot initialized successfully")
                break
            except Exception as init_error:
                if "Timed out" in str(init_error) or "ConnectTimeout" in str(init_error):
                    if init_attempt < max_init_retries - 1:
                        logger.warning(f"Bot initialization failed (attempt {init_attempt + 1}). Retrying in {init_delay} seconds...")
                        time.sleep(init_delay)
                        init_delay *= 2
                        continue
                    else:
                        logger.error("Failed to initialize bot after multiple attempts")
                        raise
                else:
                    raise
        
        # Initialize CryptoBot payment database tables
        if bot.payment_manager:
            try:
                from cryptobot_payment import create_payment_tables
                # Initialize tables synchronously to avoid event loop conflict
                import asyncio
                try:
                    # Try to run in existing event loop
                    try:
                        loop = asyncio.get_running_loop()
                        # Loop is running - schedule the coroutine
                        asyncio.create_task(create_payment_tables(bot.casino.db))
                    except RuntimeError:
                        # No event loop is running, run it
                        asyncio.run(create_payment_tables(bot.casino.db))
                except Exception as e:
                    # Handle case where no event loop exists
                    asyncio.run(create_payment_tables(bot.casino.db))
                logger.info("CryptoBot payment tables initialized successfully")
            except Exception as e:
                logger.error(f"Payment tables initialization error: {e}")
        else:
            logger.info("Payment system not available - skipping payment table creation")
        
        # Initialize advanced features
        try:
            from advanced_features import initialize_advanced_features
            initialize_advanced_features(bot.casino.db)
            logger.info("Advanced features initialized successfully")
        except ImportError:
            logger.warning("Advanced features module not found - running with basic functionality")
        
        # Initialize Solana systems
        try:
            from solana_integration_init import initialize_solana_integration

            # Initialize enhanced Solana integration
            logger.info("Starting enhanced Solana integration...")
            # Note: Full initialization should be run separately via solana_integration_init.py

            # Start webhook server for automatic payments
            try:
                from webhook_server import start_webhook_server_thread
                start_webhook_server_thread(host='0.0.0.0', port=8080)
                logger.info("âœ… Webhook server started for automatic payments")
            except ImportError:
                logger.warning("Webhook server not available")

            logger.info("Solana integration system ready")
        except ImportError:
            logger.warning("Enhanced Solana integration not found")
        except Exception as e:
            logger.error(f"Failed to initialize Solana integration: {e}")
        
        # Create application
        if not BOT_TOKEN or BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
            logger.error("ERROR: BOT_TOKEN not configured! Please set your bot token in config.py")
            sys.exit(1)
        
        # Configure request settings with timeout and retry logic
        from telegram.request import HTTPXRequest
        import httpx
        
        # Create custom request object with longer timeout
        request = HTTPXRequest(
            connection_pool_size=8,
            read_timeout=60,
            write_timeout=60,
            connect_timeout=60,
            pool_timeout=30,
            http_version="1.1"
        )
        
        application = Application.builder().token(BOT_TOKEN).request(request).build()
        
        # Add handlers - Support and dice game commands only
        application.add_handler(CommandHandler("support", support_command))
        application.add_handler(CommandHandler("diceslots", diceslots_command))
        application.add_handler(CommandHandler("dartgame", dartgame_command))
        application.add_handler(CommandHandler("classicdice", classicdice_command))
        application.add_handler(CommandHandler("basketball", basketball_command))
        application.add_handler(CommandHandler("football", football_command))
        application.add_handler(CommandHandler("bowling", bowling_command))
        application.add_handler(CallbackQueryHandler(button_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))
        
        # Add group event handlers for automatic bot startup
        from telegram.ext import ChatMemberHandler
        application.add_handler(ChatMemberHandler(handle_my_chat_member, ChatMemberHandler.MY_CHAT_MEMBER))
        application.add_handler(ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER))
        
        # Add error handler
        application.add_error_handler(error_handler)

        # Start the bot
        logger.info("Casino Bot is starting...")
        logger.info("Payment system: " + ("Enabled" if bot.payment_manager else "Disabled (Offline mode)"))
        logger.info("Bot is ready to receive messages!")

        # Run the bot
        logger.info("SUCCESS: Casino system initialized")
        logger.info("SUCCESS: CryptoBot integration initialized")

        # Run polling mode with retry logic for connection issues
        max_retries = 5
        retry_delay = 10

        # Use asyncio.run to handle event loop properly
        async def run_bot():
            """Run the bot in a proper async context"""
            await application.initialize()

            # Setup bot commands after initialization
            try:
                await setup_bot_commands(application.bot)
            except Exception as cmd_error:
                logger.error(f"Failed to setup bot commands: {cmd_error}")

            # Start the bot using the modern approach
            await application.run_polling(drop_pending_updates=True)

        # Create HTTPx request with proper configuration
        from telegram.request import HTTPXRequest
        request = HTTPXRequest(
            connection_pool_size=512,
            read_timeout=30,
            write_timeout=30,
            connect_timeout=60,
            pool_timeout=30,
            http_version="1.1"
        )

        application = Application.builder().token(BOT_TOKEN).request(request).build()

        # Add startup callback for async initialization
        async def startup_callback(application):
            """Initialize async components after bot starts"""
            try:
                await bot.async_init_solana()
            except Exception as e:
                logger.error(f"Solana async initialization failed: {e}")

        application.post_init = startup_callback

        # Add handlers - Support and dice game commands only
        application.add_handler(CommandHandler("support", support_command))
        application.add_handler(CommandHandler("diceslots", diceslots_command))
        application.add_handler(CommandHandler("dartgame", dartgame_command))
        application.add_handler(CommandHandler("classicdice", classicdice_command))
        application.add_handler(CommandHandler("basketball", basketball_command))
        application.add_handler(CommandHandler("football", football_command))
        application.add_handler(CommandHandler("bowling", bowling_command))
        application.add_handler(CallbackQueryHandler(button_callback))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text_message))

        # Add group event handlers for automatic bot startup
        from telegram.ext import ChatMemberHandler
        application.add_handler(ChatMemberHandler(handle_my_chat_member, ChatMemberHandler.MY_CHAT_MEMBER))
        application.add_handler(ChatMemberHandler(handle_chat_member, ChatMemberHandler.CHAT_MEMBER))

        # Add error handler
        application.add_error_handler(error_handler)

        for attempt in range(max_retries + 1):
            try:
                logger.info(f"Starting polling attempt {attempt + 1}/{max_retries + 1}")

                # Ensure we have an event loop
                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    # No running loop, create new one
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)

                # Run the bot using the synchronous method
                application.run_polling(drop_pending_updates=True)
                break  # If successful, exit the retry loop

            except RuntimeError as e:
                if "There is no current event loop" in str(e) or "Event loop is closed" in str(e):
                    logger.warning(f"Event loop issue on attempt {attempt + 1}: {e}")
                    # Let the application handle event loop creation on retry

                    if attempt < max_retries:
                        logger.info(f"Created new event loop, retrying...")
                        continue
                    else:
                        logger.error("Max retries reached for event loop errors")
                        raise
                else:
                    raise
            except (TimedOut, NetworkError, httpx.ReadError, httpx.ConnectError, httpx.TimeoutException) as e:
                if attempt < max_retries:
                    logger.warning(f"Network error on attempt {attempt + 1}: {e}. Retrying in {retry_delay} seconds...")
                    time.sleep(retry_delay)
                    retry_delay = min(retry_delay * 1.5, 60)  # Exponential backoff with cap
                    continue
                else:
                    logger.error("Max retries reached. Network connection failed.")
                    raise
            except Exception as e:
                if "Timed out" in str(e) or "TimedOut" in str(e) or "ConnectTimeout" in str(e) or "ReadTimeout" in str(e):
                    if attempt < max_retries:
                        logger.warning(f"Connection timeout on attempt {attempt + 1}. Retrying in {retry_delay} seconds...")
                        time.sleep(retry_delay)
                        retry_delay = min(retry_delay * 1.5, 60)  # Exponential backoff with cap
                        continue
                    else:
                        logger.error("Max retries reached. Connection failed.")
                        raise
                else:
                    raise
        
    except Exception as e:
        logger.error(f"FATAL ERROR: {e}")
        cleanup_pid_file(pid_file)
        raise
    finally:
        cleanup_pid_file(pid_file)

# Enhanced game handler with animations and detailed feedback
async def handle_enhanced_solo_game(query, user, game_type, bet_amount, casino_bot, bot_instance):
    """Enhanced solo game with animations and detailed results"""
    try:
        import asyncio
        import random
        
        # Clear previous game content and show loading animation
        await query.edit_message_text("ğŸ® Yeni oyun hazÄ±rlanÄ±yor...")
        await asyncio.sleep(0.2)
        
        loading_frames = ["â³", "â°", "â±ï¸", "â²ï¸"]
        for frame in loading_frames:
            await query.edit_message_text(f"{frame} Oyun baÅŸlÄ±yor...")
            await asyncio.sleep(0.3)
        
        # Create solo game engine if not exists
        if not hasattr(casino_bot, 'solo_engine'):
            from solo_games import SoloGameEngine
            casino_bot.solo_engine = SoloGameEngine()
        
        # Play the game based on type
        result = None
        
        # Safety check for solo engine
        if not hasattr(casino_bot.solo_engine, 'play_solo_slots'):
            raise AttributeError("Solo engine methods not available")
            
        if game_type == "solo_slots":
            result = casino_bot.solo_engine.play_solo_slots(bet_amount)
            if result is None:
                # Fallback result if engine returns None
                result = {
                    'reels': ['âŒ', 'âŒ', 'âŒ'],
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0
                }
            result_text = f"""
ğŸ° **SLOT MAKÄ°NESÄ°** ğŸ°

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ¯ **SonuÃ§:** {' '.join(result['reels'])}
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸŒŸ MuhteÅŸem! Devam et!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ€ ÅansÄ±n bir dahaki sefere!
"""
        
        elif game_type == "solo_roulette":
            bet_choice = "red"
            result = casino_bot.solo_engine.play_solo_roulette(bet_amount, "color", bet_choice)
            if result is None:
                # Fallback result if engine returns None
                result = {
                    'number': 0,
                    'color': 'green',
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0
                }
            color_emoji = "ğŸ”´" if result['color'] == "red" else "âš«" if result['color'] == "black" else "ğŸŸ¢"
            
            result_text = f"""
ğŸ¯ **RULET** ğŸ¯

ğŸ® **Bahis:** {bet_amount:,} ğŸ» ({bet_choice})
ğŸ² **SonuÃ§:** {result['number']} {color_emoji}
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸ¯ MÃ¼kemmel tahmin!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ² Bir dahaki sefere ÅŸansÄ±n!
"""
                
        elif game_type == "solo_blackjack":
            result = casino_bot.solo_engine.play_solo_blackjack(bet_amount)
            if result is None:
                # Fallback result if engine returns None
                result = {
                    'player_cards': [1, 10],
                    'dealer_cards': [5, 10],
                    'player_value': 21,
                    'dealer_value': 15,
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0
                }
            card_display = lambda cards: ' '.join([{1: 'A', 11: 'J', 12: 'Q', 13: 'K'}.get(c, str(c)) for c in cards])
            
            result_text = f"""
ğŸƒ **BLACKJACK** ğŸƒ

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ‘¤ **Sen:** {card_display(result['player_cards'])} (DeÄŸer: {result['player_value']})
ğŸª **Krupiye:** {card_display(result['dealer_cards'])} (DeÄŸer: {result['dealer_value']})
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸƒ Harika oynama!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ¯ Stratejini geliÅŸtir!
"""
        
        elif game_type == "solo_crash":
            result = casino_bot.solo_engine.play_solo_crash(bet_amount)
            if result is None:
                result = {
                    'crash_point': 1.0,
                    'cashout_multiplier': 2.0,
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0,
                    'result_text': 'Engine Error'
                }
            result_text = f"""
ğŸš€ **CRASH GAME** ğŸš€

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ¯ **SonuÃ§:** {result['result_text']}
ğŸ’¥ **Crash Point:** {result['crash_point']:.1f}x
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸš€ Harika zamanlama!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ€ Bir dahaki sefere daha erken Ã§Ä±k!
"""
        
        elif game_type == "solo_mines":
            result = casino_bot.solo_engine.play_solo_mines(bet_amount)
            if result is None:
                result = {
                    'mines_count': 3,
                    'gems_found': 0,
                    'hit_mine': True,
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0,
                    'result_text': 'Engine Error'
                }
            result_text = f"""
ğŸ’ **MINES GAME** ğŸ’

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
â›ï¸ **SonuÃ§:** {result['result_text']}
ğŸ’£ **MayÄ±n SayÄ±sÄ±:** {result['mines_count']}
ğŸ’ **Bulunan MÃ¼cevher:** {result['gems_found']}
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸ’ MÃ¼kemmel kazÄ±!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ’£ MayÄ±na bastÄ±n! Daha dikkatli ol!
"""
        
        elif game_type == "solo_baccarat":
            result = casino_bot.solo_engine.play_solo_baccarat(bet_amount)
            if result is None:
                result = {
                    'winner': 'banker',
                    'player_val': 5,
                    'banker_val': 7,
                    'bet_on': 'player',
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0,
                    'result_text': 'Engine Error'
                }
            result_text = f"""
ğŸƒ **BACCARAT** ğŸƒ

ğŸ® **Bahis:** {bet_amount:,} ğŸ» ({result['bet_on']})
ğŸ‘¤ **Oyuncu:** {result['player_val']}
ğŸ¦ **Banker:** {result['banker_val']}
ğŸ† **Kazanan:** {result['winner'].title()}
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸƒ Profesyonel tahmin!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ¯ ÅansÄ±n bir dahaki sefere!
"""
        
        elif game_type == "solo_keno":
            result = casino_bot.solo_engine.play_solo_keno(bet_amount)
            if result is None:
                result = {
                    'hits': 0,
                    'numbers_chosen': list(range(1, 11)),
                    'hit_numbers': [],
                    'won': False,
                    'win_amount': 0,
                    'multiplier': 0,
                    'result_text': 'Engine Error'
                }
            result_text = f"""
ğŸ² **KENO** ğŸ²

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ¯ **SeÃ§ilen:** {', '.join(map(str, result['numbers_chosen'][:5]))}...
ğŸ° **EÅŸleÅŸen:** {result['hits']} sayÄ±
ğŸ’ **EÅŸleÅŸenler:** {', '.join(map(str, result['hit_numbers']))}
"""
            if result['won']:
                result_text += f"""
ğŸ‰ **YOU WON!** ğŸ‰
ğŸ» **KazanÃ§:** {result['win_amount']:,} ğŸ»
âš¡ **Multiplier:** {result['multiplier']:.2f}x
âœ¨ **Net Kar:** +{result['win_amount'] - bet_amount:,} ğŸ»

ğŸ² Harika tahminler!
"""
            else:
                result_text += f"""
ğŸ˜¢ **Kaybettin** ğŸ˜¢
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ€ Daha fazla eÅŸleÅŸme iÃ§in ÅŸansÄ±nÄ± dene!
"""
        
        # Fallback for unhandled game types
        if result is None:
            result = {
                'won': False,
                'win_amount': 0,
                'multiplier': 0
            }
            result_text = f"""
âŒ **OYUN HATASI** âŒ

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
âš ï¸ **Status:** Game engine error
ğŸ’¸ **Loss:** -{bet_amount:,} ğŸ»

ğŸ”„ Please try again.
"""
        
        # Update user stats and save game
        casino_bot.update_user_stats(user['user_id'], bet_amount, result['win_amount'], result['won'])
        casino_bot.save_solo_game(user['user_id'], game_type, bet_amount, result)
        
        # Get updated balance
        updated_user = casino_bot.get_user(user['user_id'])
        result_text += f"\nğŸ» **Yeni Bakiye:** {updated_user['fun_coins']:,} ğŸ»"
        
        # Interactive buttons
        buttons = [
            [("ğŸ”„ Tekrar Oyna", f"solo_{game_type.split('_')[1]}"), ("ğŸ® BaÅŸka Oyun", "solo_games")],
            [("ğŸ“Š DetaylÄ± Profil", "profile"), ("ğŸ» Para Ä°ÅŸlemleri", "payment_menu")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Enhanced solo game error: {e}")
        await query.edit_message_text(
            "âŒ Oyun sÄ±rasÄ±nda error occurred!\n\nğŸ”„ Please try again.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ® Solo Games", "solo_games")]])
        )

# Complete tournament system functions
async def show_tournament_menu(query, user, casino_bot):
    """Tournament page - Coming Soon"""
    text = """ğŸ† **TOURNAMENTS** ğŸ†

ğŸš§ **Coming Soon!** ğŸš§

ğŸŠ **Upcoming Features:**
â€¢ Weekly Tournaments - Massive prize pools
â€¢ Live Leaderboards - Real-time rankings  
â€¢ Special Events - Seasonal competitions
â€¢ Team Battles - Group vs Group
â€¢ Championship Series - Multi-round tournaments

â° **Stay tuned for the biggest casino tournaments!**

ğŸ® **In the meantime, enjoy our solo games and duels!**
    """
    
    buttons = [
        [("ğŸ® Solo Games", "solo_games"), ("âš”ï¸ Create Duel", "create_duel")],
        [("ğŸ¯ Join Duel", "join_duel"), ("ğŸ“Š Leaderboard", "leaderboard")],
        [("ğŸ  Main Menu", "main_menu")]
    ]
    
    keyboard = casino_bot.create_keyboard(buttons)
    await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')

async def handle_create_tournament(query, user, tournament_type, casino_bot):
    """Handle tournament creation"""
    try:
        from advanced_features import tournament_manager
        
        if not tournament_manager:
            await query.edit_message_text(
                "âŒ Turnuva sistemi ÅŸu anda kullanÄ±lamÄ±yor.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            return
        
        result = tournament_manager.create_tournament(tournament_type, user['user_id'])
        
        if result["success"]:
            tournament = result["tournament"]
            text = f"""
âœ… **TURNUVA OLUÅTURULDU!** âœ…

ğŸ† **{tournament['name']}**
ğŸ» **Buy-in:** {tournament['buy_in']:,} ğŸ»
ğŸ‘¥ **Max Oyuncu:** {tournament['max_players']}
â° **BaÅŸlama:** 2 dakika sonra
ğŸ® **Oyun TÃ¼rÃ¼:** {tournament['game_type'].title()}

ğŸ“‹ **Turnuva ID:** {tournament['id']}

ğŸŒŸ DiÄŸer oyuncularÄ±n katÄ±lmasÄ±nÄ± bekleyin!
ğŸ’¡ Minimum 2 oyuncu gerekli.
            """
            
            buttons = [
                [("ğŸ”„ Turnuvalar", "tournaments"), ("ğŸ‘¥ ArkadaÅŸ Davet Et", "friends")],
                [("ğŸ“Š Profil", "profile"), ("ğŸ  Main Menu", "main_menu")]
            ]
        else:
            text = f"âŒ **Turnuva oluÅŸturulamadÄ±:** {result['error']}"
            buttons = [
                [("ğŸ”„ Tekrar Dene", "tournaments"), ("ğŸ  Main Menu", "main_menu")]
            ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Create tournament error: {e}")

async def handle_join_tournament(query, user, tournament_id, casino_bot):
    """Handle joining tournament"""
    try:
        from advanced_features import tournament_manager
        
        if not tournament_manager:
            await query.edit_message_text(
                "âŒ Turnuva sistemi ÅŸu anda kullanÄ±lamÄ±yor.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            return
        
        result = tournament_manager.join_tournament(tournament_id, user['user_id'], user['fun_coins'])
        
        if result["success"]:
            tournament = result["tournament"]
            participants_count = len(tournament["participants"])
            
            text = f"""
ğŸ‰ **TURNUVAYA KATILDIN!** ğŸ‰

ğŸ† **{tournament['name']}**
ğŸ» **Buy-in Ã–dendi:** {tournament['buy_in']:,} ğŸ»
ğŸ‘¥ **KatÄ±lÄ±mcÄ±:** {participants_count}/{tournament['max_players']}
ğŸ† **GÃ¼ncel Ã–dÃ¼l Havuzu:** {tournament['prize_pool']:,} ğŸ»

â° **Durum:** {'BaÅŸlÄ±yor...' if participants_count >= 2 else 'Daha fazla oyuncu bekleniyor'}

ğŸ¯ **Ã–dÃ¼l DaÄŸÄ±lÄ±mÄ±:**
ğŸ¥‡ 1. - %50 ({int(tournament['prize_pool'] * 0.5):,} ğŸ»)
ğŸ¥ˆ 2. - %30 ({int(tournament['prize_pool'] * 0.3):,} ğŸ»)
ğŸ¥‰ 3. - %20 ({int(tournament['prize_pool'] * 0.2):,} ğŸ»)
            """
            
            # Auto-start tournament if enough players
            if participants_count >= 2:
                start_result = tournament_manager.start_tournament(tournament_id)
                if start_result["success"]:
                    text += f"\nğŸš€ **TURNUVA BAÅLADI!**\n"
                    results = start_result["results"]
                    winner_id = start_result["winner_id"]
                    
                    text += "\nğŸ“Š **SONUÃ‡LAR:**\n"
                    for i, result in enumerate(results[:3]):
                        position_emoji = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰"][i]
                        user_info = casino_bot.get_user(result["user_id"])
                        username = user_info['username'] or f"Oyuncu{result['user_id']}"
                        prize = result['prize'] if 'prize' in result else 0
                        text += f"{position_emoji} {username} - {result['score']} puan"
                        if prize > 0:
                            text += f" (+{prize:,} ğŸ»)"
                        text += "\n"
            
        else:
            text = f"âŒ **Turnuvaya katÄ±lamadÄ±n:** {result['error']}"
        
        buttons = [
            [("ğŸ”„ Turnuvalar", "tournaments"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Join tournament error: {e}")

# Complete friend system functions
async def show_simple_friends_menu(query, user, casino_bot):
    """Show simple friends menu"""
    try:
        with casino_bot.db.get_connection() as conn:
            # Get friends
            friends = conn.execute('''
                SELECT u.username, u.level, u.fun_coins, u.last_active FROM friendships f 
                JOIN users u ON (CASE WHEN f.user1_id = ? THEN f.user2_id ELSE f.user1_id END) = u.user_id 
                WHERE (f.user1_id = ? OR f.user2_id = ?) AND f.status = "accepted"
                ORDER BY u.last_active DESC
            ''', (user['user_id'], user['user_id'], user['user_id'])).fetchall()
            
            # Get pending requests
            pending_requests = conn.execute('''
                SELECT COUNT(*) FROM friendships 
                WHERE user2_id = ? AND status = "pending"
            ''', (user['user_id'],)).fetchone()[0]
        
        text = "ğŸ‘¥ **ARKADAÅ SÄ°STEMÄ°** ğŸ‘¥\n\n"
        
        if friends:
            text += f"ğŸ‘« **ArkadaÅŸlarÄ±n ({len(friends)}):**\n\n"
            for friend in friends[:5]:  # Show first 5
                status = "ğŸŸ¢" if friend['last_active'] and (datetime.now() - datetime.fromisoformat(friend['last_active'])).days < 1 else "ğŸ”´"
                text += f"{status} **{friend['username'] or 'Anonim'}** (Lv.{friend['level']})\n"
                text += f"    ğŸ» {friend['fun_coins']:,} ğŸ»\n\n"
            
            if len(friends) > 5:
                text += f"... ve {len(friends) - 5} arkadaÅŸÄ±n daha\n\n"
        else:
            text += "ğŸ˜” HenÃ¼z arkadaÅŸÄ±n yok!\n\n"
        
        if pending_requests > 0:
            text += f"ğŸ“¬ **{pending_requests} bekleyen arkadaÅŸlÄ±k isteÄŸin var!**\n\n"
        
        text += f"ğŸ†” **Senin ArkadaÅŸ Kodun:** `{user['friend_code'] if 'friend_code' in user.keys() else 'ERROR'}`\n\n"
        text += "ğŸ’¡ **NasÄ±l Ã‡alÄ±ÅŸÄ±r:**\n"
        text += "â€¢ ArkadaÅŸ kodunu paylaÅŸ\n"
        text += "â€¢ BaÅŸkalarÄ±nÄ±n kodunu gir\n"
        text += "â€¢ Beraber turnuvalara katÄ±l\n"
        text += "â€¢ GÃ¼nlÃ¼k bonuslar kazan!\n"
        
        buttons = [
            [("â• ArkadaÅŸ Ekle", "add_friend"), ("ğŸ“¬ Ä°stekler", "friend_requests")],
            [("ğŸ® ArkadaÅŸlarla Oyna", "tournaments"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Friends menu error: {e}")

async def show_add_friend_menu(query, user, casino_bot):
    """Show add friend menu"""
    try:
        text = f"""
â• **ARKADAÅ EKLE** â•

ğŸ†” **Senin Kodun:** `{user['friend_code'] if 'friend_code' in user.keys() else 'ERROR'}`

ğŸ“ **ArkadaÅŸ Kodu Gir:**
ArkadaÅŸÄ±nÄ±n 6 haneli kodunu gir ve arkadaÅŸlÄ±k isteÄŸi gÃ¶nder!

ğŸ’¡ **Tips:**
â€¢ Kod 6 hane ve harf-rakam karÄ±ÅŸÄ±mÄ±
â€¢ BÃ¼yÃ¼k-kÃ¼Ã§Ã¼k harf duyarlÄ± deÄŸil
â€¢ Kendi kodunu giremezsin

ğŸ **Referans Sistemi:**
â€¢ Referans kodunla kayÄ±t: +1000 ğŸ»
â€¢ Referans eden kiÅŸi: +500 ğŸ»
â€¢ ReferanslarÄ±n oynadÄ±kÃ§a %5 komisyon

ğŸ”— **PaylaÅŸÄ±m Metni:**
ğŸ® Casino Bot'ta eÄŸlenelim! Kodum: `{user['friend_code'] if 'friend_code' in user.keys() else 'ERROR'}`

ğŸ“± **Referans Linki:**
https://t.me/bot_username?start=friend_{user['friend_code'] if 'friend_code' in user.keys() else 'ERROR'}
        """
        
        buttons = [
            [("ğŸ“ Manuel Kod Gir", "enter_friend_code")],
            [("ğŸ“‹ Kodu Kopyala", "copy_friend_code"), ("ğŸ“¤ PaylaÅŸ", "share_friend_code")],
            [("ğŸ‘¥ ArkadaÅŸlarÄ±m", "friends"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Add friend menu error: {e}")

async def show_friend_requests_menu(query, user, casino_bot):
    """Show friend requests menu"""
    try:
        requests = casino_bot.get_friend_requests(user['user_id'])
        
        text = "ğŸ“¬ **ARKADAÅLIK Ä°STEKLERÄ°** ğŸ“¬\n\n"
        
        if requests:
            text += f"ğŸ“¥ **{len(requests)} bekleyen istek:**\n\n"
            buttons = []
            
            for request in requests[:5]:  # Show max 5
                username = request['username'] or f"Oyuncu{request['user1_id']}"
                date = request['created_at'][:10]
                
                text += f"ğŸ‘¤ **{username}** (Lv.{request['level']})\n"
                text += f"ğŸ“… GÃ¶nderim: {date}\n\n"
                
                buttons.append([
                    (f"âœ… Kabul: {username[:10]}", f"accept_friend_{request['user1_id']}"),
                    (f"âŒ Reddet", f"reject_friend_{request['user1_id']}")
                ])
            
            buttons.append([("ğŸ”„ Yenile", "friend_requests"), ("ğŸ‘¥ ArkadaÅŸlar", "friends")])
            
        else:
            text += "ğŸ˜Š Bekleyen arkadaÅŸlÄ±k isteÄŸin yok!\n\n"
            text += "ğŸ’¡ **ArkadaÅŸ Bulmak Ä°Ã§in:**\n"
            text += "â€¢ Kodunu arkadaÅŸlarÄ±nla paylaÅŸ\n"
            text += "â€¢ Turnuvalarda tanÄ±ÅŸ\n"
            text += "â€¢ Liderlik tablosundaki oyuncularÄ± takip et\n"
            
            buttons = [
                [("â• ArkadaÅŸ Ekle", "add_friend"), ("ğŸ† Turnuvalar", "tournaments")],
                [("ğŸ“Š Liderlik", "leaderboard"), ("ğŸ  Main Menu", "main_menu")]
            ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Friend requests error: {e}")

async def handle_accept_friend(query, user, friend_id, casino_bot):
    """Handle accepting friend request"""
    try:
        success = casino_bot.accept_friend_request(user['user_id'], friend_id)
        
        if success:
            # Get friend info
            friend = casino_bot.get_user(friend_id)
            friend_name = friend['username'] or f"Oyuncu{friend_id}"
            
            # Give bonus coins
            with casino_bot.db.get_connection() as conn:
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?', (300, user['user_id']))
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?', (300, friend_id))
                conn.commit()
            
            # Unlock achievement
            casino_bot.unlock_achievement(user['user_id'], "social_butterfly")
            
            text = f"""
ğŸ‰ **ARKADAÅLIK KABUL EDÄ°LDÄ°!** ğŸ‰

ğŸ‘¥ **{friend_name}** artÄ±k arkadaÅŸÄ±n!

ğŸ **Bonuslar:**
â€¢ +300 ğŸ» (Sen)
â€¢ +300 ğŸ» ({friend_name})

ğŸŒŸ **ArtÄ±k yapabileceklerin:**
â€¢ Beraber turnuvalara katÄ±lÄ±n
â€¢ Birbirinizi dÃ¼elloya davet edin
â€¢ Referans komisyonlarÄ± kazanÄ±n
â€¢ AchievementmlarÄ± paylaÅŸÄ±n

ğŸ† **Achievementm AÃ§Ä±ldÄ±:** Sosyal Kelebek!
            """
        else:
            text = "âŒ ArkadaÅŸlÄ±k isteÄŸi kabul edilemedi!"
        
        buttons = [
            [("ğŸ“¬ DiÄŸer Ä°stekler", "friend_requests"), ("ğŸ‘¥ ArkadaÅŸlar", "friends")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Accept friend error: {e}")

async def handle_reject_friend(query, user, friend_id, casino_bot):
    """Handle rejecting friend request"""
    try:
        with casino_bot.db.get_connection() as conn:
            conn.execute('DELETE FROM friendships WHERE user1_id = ? AND user2_id = ? AND status = "pending"',
                        (friend_id, user['user_id']))
            conn.commit()
        
        text = "âŒ ArkadaÅŸlÄ±k isteÄŸi reddedildi."
        
        buttons = [
            [("ğŸ“¬ DiÄŸer Ä°stekler", "friend_requests"), ("ğŸ‘¥ ArkadaÅŸlar", "friends")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Reject friend error: {e}")

# Events system
async def show_events_menu(query, user, casino_bot):
    """Show events and special content"""
    try:
        from advanced_features import event_manager
        
        # Get current date for seasonal events
        now = datetime.now()
        seasonal_events = []
        
        # Check for seasonal events
        if now.month == 12:
            seasonal_events.append({
                "name": "ğŸ„ Noel Casino Festivali",
                "description": "TÃ¼m gÃ¼nlÃ¼k bonuslar 2x!",
                "active": True,
                "bonus": "2x gÃ¼nlÃ¼k bonus"
            })
        
        if now.month == 1 and now.day <= 7:
            seasonal_events.append({
                "name": "ğŸŠ Yeni YÄ±l Åans HaftasÄ±",
                "description": "3x XP ve Ã¶zel achievementslar!",
                "active": True,
                "bonus": "3x XP"
            })
        
        if now.month in [6, 7, 8]:
            seasonal_events.append({
                "name": "â˜€ï¸ Yaz Casino Festivali",
                "description": "Plaj temalÄ± oyunlar ve bonuslar!",
                "active": True,
                "bonus": "1.5x tÃ¼m bonuslar"
            })
        
        # Daily challenges
        win_streak = user['win_streak'] if user['win_streak'] is not None else 0
        daily_challenge = {
            "name": "ğŸ¯ GÃ¼nlÃ¼k Meydan Okuma",
            "description": "5 oyun art arda kazan",
            "reward": "2,000 ğŸ»",
            "progress": f"{win_streak}/5",
            "completed": win_streak >= 5
        }
        
        text = "ğŸ‰ **ETKÄ°NLÄ°KLER VE Ã–ZEL Ä°Ã‡ERÄ°K** ğŸ‰\n\n"
        
        if seasonal_events:
            text += "ğŸŒŸ **Active Mevsimsel Etkinlikler:**\n\n"
            for event in seasonal_events:
                text += f"ğŸª **{event['name']}**\n"
                text += f"ğŸ“ {event['description']}\n"
                text += f"ğŸ Bonus: {event['bonus']}\n\n"
        
        text += "ğŸ¯ **GÃ¼nlÃ¼k Meydan Okuma:**\n\n"
        status = "âœ… TamamlandÄ±!" if daily_challenge['completed'] else f"ğŸ“Š Ä°lerleme: {daily_challenge['progress']}"
        text += f"ğŸ† **{daily_challenge['name']}**\n"
        text += f"ğŸ“‹ {daily_challenge['description']}\n"
        text += f"ğŸ» Ã–dÃ¼l: {daily_challenge['reward']}\n"
        text += f"ğŸ¯ Durum: {status}\n\n"
        
        text += "ğŸª **Ã–zel Etkinlikler:**\n"
        text += "â€¢ ğŸ HaftalÄ±k YarÄ±ÅŸ (Pazartesi baÅŸlÄ±yor)\n"
        text += "â€¢ ğŸ° Jackpot Saatleri (Her gÃ¼n 20:00-22:00)\n"
        text += "â€¢ ğŸŠ Hafta Sonu Bonusu (%50 ekstra)\n"
        text += "â€¢ ğŸ¯ AylÄ±k BÃ¼yÃ¼k Turnuva (Her ayÄ±n 1'i)\n\n"
        
        text += "ğŸ“… **YaklaÅŸan Etkinlikler:**\n"
        text += "â€¢ ğŸ† Mega Turnuva (Gelecek Hafta)\n"
        text += "â€¢ ğŸ Ã–zel Bonus GÃ¼nÃ¼ (Cuma)\n"
        text += "â€¢ ğŸª VIP Ã–zel EtkinliÄŸi (AyÄ±n 15'i)\n\n"
        text += f"ğŸ• **Son GÃ¼ncelleme:** {now.strftime('%H:%M:%S')}\n"
        
        buttons = [
            [("ğŸ¯ GÃ¼nlÃ¼k GÃ¶revler", "daily_quests"), ("ğŸ† Turnuvalar", "tournaments")],
            [("ğŸ Daily Bonus", "daily_bonus"), ("ğŸ‘‘ VIP Bilgisi", "vip_info")],
            [("ğŸ”„ Yenile", "events"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        
        try:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        except Exception as telegram_error:
            # Handle "message not modified" error silently
            if "Message is not modified" in str(telegram_error):
                logger.debug("Events menu: Message content unchanged, skipping update")
            else:
                raise telegram_error
        
    except Exception as e:
        logger.error(f"Events menu error: {e}")
        await query.edit_message_text(
            "âŒ Etkinlik menÃ¼sÃ¼ yÃ¼klenirken error occurred!",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

# Duel system functions
async def show_create_duel_menu(query, user, casino_bot):
    """Show create duel menu"""
    try:
        text = f"""
âš”ï¸ **DÃœELLO OLUÅTUR** âš”ï¸

ğŸ» **Current Balance:** {user['fun_coins']:,} ğŸ»

ğŸ® **DÃ¼ello TÃ¼rleri:**

ğŸª™ **Coin Flip** (Min: 10 ğŸ»)
â€¢ YazÄ±-tura tahmin et
â€¢ %50 kazanma ÅŸansÄ±
â€¢ 2x Ã¶deme

ğŸ² **Zar DÃ¼ellolarÄ±:**
â€¢ ğŸ² Standart Zar (Min: 10 ğŸ»)
â€¢ ğŸ€ Basketbol Zar (Min: 15 ğŸ»)
â€¢ âš½ Futbol Zar (Min: 15 ğŸ»)
â€¢ ğŸ° Slot Zar (Min: 20 ğŸ»)
â€¢ ğŸ³ Bowling Zar (Min: 12 ğŸ»)
â€¢ ğŸ¯ Dart Zar (Min: 10 ğŸ»)

âœŠ **Rock-Paper-Scissors** (Min: 20 ğŸ»)
â€¢ Klasik taÅŸ-kaÄŸÄ±t-makas
â€¢ Strateji gerektirir
â€¢ 2x Ã¶deme

ğŸ’¡ **DÃ¼ello KurallarÄ±:**
â€¢ Her oyuncu aynÄ± miktarÄ± yatÄ±rÄ±r
â€¢ Kazanan tÃ¼m parayÄ± alÄ±r
â€¢ Berabere durumda paralar iade edilir
â€¢ Otomatik sonuÃ§ hesaplama
        """
        
        buttons = []
        
        # Check balance for each game
        if user['fun_coins'] >= 10:
            buttons.append([("ğŸª™ Coin Flip (10 ğŸ»)", "create_duel_duel_coinflip")])
        else:
            buttons.append([("ğŸª™ Coin Flip (Yetersiz)", "insufficient_funds")])
        
        # Dice game buttons
        dice_games = [
            ("ğŸ² Standart Zar (10 ğŸ»)", "create_duel_duel_dice_standard", 10),
            ("ğŸ€ Basketbol Zar (15 ğŸ»)", "create_duel_duel_dice_basketball", 15),
            ("âš½ Futbol Zar (15 ğŸ»)", "create_duel_duel_dice_football", 15),
            ("ğŸ° Slot Zar (20 ğŸ»)", "create_duel_duel_dice_slot", 20),
            ("ğŸ³ Bowling Zar (12 ğŸ»)", "create_duel_duel_dice_bowling", 12),
            ("ğŸ¯ Dart Zar (10 ğŸ»)", "create_duel_duel_dice_darts", 10)
        ]
        
        for button_text, callback, min_bet in dice_games:
            if user['fun_coins'] >= min_bet:
                buttons.append([(button_text, callback)])
            else:
                buttons.append([(button_text.replace("FC)", "Yetersiz)"), "insufficient_funds")])
        
        if user['fun_coins'] >= 20:
            buttons.append([("âœŠ Rock-Paper-Scissors (20 ğŸ»)", "create_duel_duel_rockpaper")])
        else:
            buttons.append([("âœŠ Rock-Paper-Scissors (Yetersiz)", "insufficient_funds")])
        
        buttons.extend([
            [("ğŸ¯ DÃ¼elloya KatÄ±l", "join_duel"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ])
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Create duel menu error: {e}")

async def show_join_duel_menu(query, user, casino_bot):
    """Show join duel menu"""
    try:
        with casino_bot.db.get_connection() as conn:
            active_duels = conn.execute('''
                SELECT ag.*, u.username FROM active_games ag 
                LEFT JOIN users u ON ag.creator_id = u.user_id 
                WHERE ag.status = "waiting" 
                AND ag.creator_id != ?
                ORDER BY ag.created_at DESC 
                LIMIT 10
            ''', (user['user_id'],)).fetchall()
        
        text = "ğŸ¯ **AKTÄ°F DÃœELLOLAR** ğŸ¯\n\n"
        
        if active_duels:
            text += f"âš”ï¸ **{len(active_duels)} aktif dÃ¼ello bulundu:**\n\n"
            buttons = []
            
            for duel in active_duels:
                creator = duel['username'] or f"Oyuncu{duel['creator_id']}"
                game_name = GAMES.get(duel['game_type'], {}).get('name', duel['game_type'])
                
                text += f"ğŸ® **{game_name}**\n"
                text += f"ğŸ‘¤ OluÅŸturan: {creator}\n"
                text += f"ğŸ» Bahis: {duel['bet_amount']:,} ğŸ»\n"
                text += f"â° OluÅŸturulma: {duel['created_at'][:16]}\n\n"
                
                if user['fun_coins'] >= duel['bet_amount']:
                    buttons.append([(f"âš”ï¸ KatÄ±l: {game_name[:12]}...", f"join_{duel['game_id']}")])
                else:
                    buttons.append([(f"âŒ Yetersiz Bakiye", "insufficient_funds")])
            
            buttons.extend([
                [("ğŸ”„ Yenile", "join_duel"), ("âš”ï¸ Yeni DÃ¼ello", "create_duel")],
                [("ğŸ  Main Menu", "main_menu")]
            ])
            
        else:
            text += "ğŸ˜” Åu anda aktif dÃ¼ello yok!\n\n"
            text += "ğŸ’¡ **Yapabileceklerin:**\n"
            text += "â€¢ Kendi dÃ¼ellonu oluÅŸtur\n"
            text += "â€¢ ArkadaÅŸlarÄ±nÄ± davet et\n"
            text += "â€¢ Turnuvalara katÄ±l\n"
            text += "â€¢ Solo oyunlarÄ± oyna\n"
            
            buttons = [
                [("âš”ï¸ DÃ¼ello OluÅŸtur", "create_duel"), ("ğŸ† Turnuvalar", "tournaments")],
                [("ğŸ‘¥ ArkadaÅŸ Davet Et", "friends"), ("ğŸ® Solo Games", "solo_games")],
                [("ğŸ”„ Yenile", "join_duel"), ("ğŸ  Main Menu", "main_menu")]
            ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Join duel menu error: {e}")

async def handle_create_duel(query, user, game_type, casino_bot):
    """Handle creating a duel"""
    try:
        from config import GAMES
        
        game_config = GAMES.get(game_type)
        if not game_config:
            await query.edit_message_text(
                "âŒ Invalid game type!",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            return
        
        min_bet = game_config['min_bet']
        
        if user['fun_coins'] < min_bet:
            await query.edit_message_text(
                f"âŒ Yetersiz bakiye!\n\nGerekli: {min_bet:,} ğŸ»\nMevcut: {user['fun_coins']:,} ğŸ»",
                reply_markup=casino_bot.create_keyboard([
                    [("ğŸ» Para YatÄ±r", "deposit_menu"), ("ğŸ Daily Bonus", "daily_bonus")],
                    [("ğŸ  Main Menu", "main_menu")]
                ])
            )
            return
        
        # Create duel
        game_id = casino_bot.create_duel(user['user_id'], game_type, min_bet)
        
        text = f"""
âš”ï¸ **DÃœELLO OLUÅTURULDU!** âš”ï¸

ğŸ® **Oyun:** {game_config['name']}
ğŸ» **Bahis:** {min_bet:,} ğŸ»
ğŸ†” **ID:** {game_id}
ğŸ‘¤ **OluÅŸturan:** {user['username'] or 'Sen'}

â³ **Durum:** Rakip bekleniyor...

ğŸ“‹ **Kurallar:**
â€¢ Ä°lk katÄ±lan rakip olur
â€¢ Otomatik oyun baÅŸlatma
â€¢ Kazanan tÃ¼m parayÄ± alÄ±r
â€¢ SonuÃ§ anÄ±nda belli olur

ğŸ”— **ArkadaÅŸlarÄ±nÄ± davet et!**
ArkadaÅŸ kodun: `{user['friend_code'] if user['friend_code'] else 'ERROR'}`
        """
        
        buttons = [
            [("ğŸ”„ DÃ¼ello Durumu", "join_duel"), ("ğŸ‘¥ ArkadaÅŸ Davet Et", "friends")],
            [("ğŸ“Š Profil", "profile"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Create duel error: {e}")

async def handle_join_game(query, user, game_id, casino_bot):
    """Handle joining a game"""
    try:
        # Check if game exists and is available
        with casino_bot.db.get_connection() as conn:
            game = conn.execute('SELECT * FROM active_games WHERE game_id = ?', (game_id,)).fetchone()
            
            if not game:
                await query.edit_message_text(
                    "âŒ Oyun bulunamadÄ±!",
                    reply_markup=casino_bot.create_keyboard([[("ğŸ¯ DÃ¼ellolar", "join_duel")]])
                )
                return
            
            if game['status'] != 'waiting':
                await query.edit_message_text(
                    "âŒ Bu oyun artÄ±k mevcut deÄŸil!",
                    reply_markup=casino_bot.create_keyboard([[("ğŸ¯ DÃ¼ellolar", "join_duel")]])
                )
                return
            
            if user['fun_coins'] < game['bet_amount']:
                await query.edit_message_text(
                    f"âŒ Yetersiz bakiye!\n\nGerekli: {game['bet_amount']:,} ğŸ»\nMevcut: {user['fun_coins']:,} ğŸ»",
                    reply_markup=casino_bot.create_keyboard([
                        [("ğŸ» Para YatÄ±r", "deposit_menu"), ("ğŸ Daily Bonus", "daily_bonus")],
                        [("ğŸ¯ DÃ¼ellolar", "join_duel")]
                    ])
                )
                return
        
        # Join the duel
        success = casino_bot.join_duel(game_id, user['user_id'])
        
        if success:
            # Show loading animation
            for i in range(3):
                await query.edit_message_text(f"â³ Oyun baÅŸlÄ±yor{'.' * (i + 1)}")
                await asyncio.sleep(0.5)
            
            # Start the game
            await start_duel_game(query, game_id, user, casino_bot)
            
        else:
            await query.edit_message_text(
                "âŒ Oyuna katÄ±lamadÄ±n! Oyun dolu olabilir.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ¯ DÃ¼ellolar", "join_duel")]])
            )
            
    except Exception as e:
        logger.error(f"Join game error: {e}")

# Admin system functions
def is_admin_user(user_id: int) -> bool:
    """Check if user is admin - reads from config.py"""
    from config import ADMIN_USER_IDS
    return user_id in ADMIN_USER_IDS

async def show_admin_panel(query, user, casino_bot):
    """Show admin control panel - only for authorized admins"""
    try:
        # Double check admin permissions
        if not is_admin_user(user['user_id']):
            await query.edit_message_text(
                "âŒ **Yetkisiz EriÅŸim!** âŒ\n\nğŸš« Bu bÃ¶lÃ¼me eriÅŸim yetkiniz yok.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            return
        text = f"""
ğŸ”§ **ADMIN CONTROL PANEL** ğŸ”§

ğŸ‘‹ HoÅŸ geldin, {user['username']}!

ğŸ® **Bot Durumu:** Online âœ…
ğŸ“Š **Sistem SaÄŸlÄ±ÄŸÄ±:** Normal âœ…
ğŸŒ **VeritabanÄ±:** BaÄŸlÄ± âœ…
ğŸ’³ **Payment Sistemi:** {"Active" if hasattr(casino_bot, 'payment_manager') else "Inactive"}

âš™ï¸ **YÃ–NETÄ°M SEÃ‡ENEKLERÄ°:**

ğŸ“Š **Statistics:**
â€¢ Bot kullanÄ±m verileri
â€¢ Oyuncu aktiviteleri
â€¢ Finansal veriler
â€¢ Performans metrikleri

ğŸ‘¥ **KullanÄ±cÄ± YÃ¶netimi:**
â€¢ KullanÄ±cÄ± listesi
â€¢ Hesap dÃ¼zenleme
â€¢ Para iÅŸlemleri
â€¢ Yasak iÅŸlemleri

ğŸ“¢ **Duyurular:**
â€¢ TÃ¼m kullanÄ±cÄ±lara mesaj
â€¢ Sistem bakÄ±m bildirimi
â€¢ Ã–zel etkinlik duyurusu

âš ï¸ **UYARI:** Admin yetkileri dikkatli kullanÄ±n!
        """
        
        buttons = [
            [("ğŸ“Š Statistics", "admin_stats"), ("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users")],
            [("ğŸ“¢ Duyuru GÃ¶nder", "admin_broadcast"), ("âš™ï¸ Sistem AyarlarÄ±", "admin_settings")],
            [("ğŸ”„ Yenile", "admin_panel"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        try:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        except Exception as edit_error:
            # Ignore "message not modified" errors
            if "Message is not modified" in str(edit_error):
                logger.debug("Admin panel: Message content unchanged, skipping update")
            else:
                raise edit_error
        
    except Exception as e:
        logger.error(f"Admin panel error: {e}")
        try:
            await query.edit_message_text(
                "âŒ **Admin Panel HatasÄ±**\n\nğŸ”„ Please try again.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
        except:
            pass

async def show_admin_statistics(query, user, casino_bot):
    """Show detailed bot statistics"""
    try:
        with casino_bot.db.get_connection() as conn:
            # User statistics
            total_users = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
            active_today = conn.execute('''
                SELECT COUNT(*) FROM users 
                WHERE date(last_active) >= date('now', '-1 day')
            ''').fetchone()[0]
            
            # Game statistics
            total_games = conn.execute('SELECT COUNT(*) FROM solo_game_history').fetchone()[0]
            games_today = conn.execute('''
                SELECT COUNT(*) FROM solo_game_history 
                WHERE date(played_at) >= date('now')
            ''').fetchone()[0]
            
            # Financial statistics
            total_coins = conn.execute('SELECT SUM(fun_coins) FROM users').fetchone()[0] or 0
            total_bets = conn.execute('SELECT SUM(bet_amount) FROM solo_game_history').fetchone()[0] or 0
            total_winnings = conn.execute('SELECT SUM(win_amount) FROM solo_game_history').fetchone()[0] or 0
            
            # Active duels and tournaments
            active_duels = conn.execute('SELECT COUNT(*) FROM active_games WHERE status = "waiting"').fetchone()[0]
            active_tournaments = conn.execute('SELECT COUNT(*) FROM tournaments WHERE status IN ("open", "registration")').fetchone()[0]
            
            # Top players
            top_players = conn.execute('''
                SELECT username, fun_coins FROM users 
                ORDER BY fun_coins DESC LIMIT 5
            ''').fetchall()
        
        house_edge = ((total_bets - total_winnings) / total_bets * 100) if total_bets > 0 else 0
        activity_rate = (active_today / total_users * 100) if total_users > 0 else 0
        
        text = f"""
ğŸ“Š **BOT STATISTICS** ğŸ“Š

ğŸ‘¥ **KULLANICILAR:**
â€¢ Toplam KullanÄ±cÄ±: {total_users:,}
â€¢ Active (24h): {active_today:,} (%{activity_rate:.1f})
â€¢ Ortalama/GÃ¼n: {total_users//30:,}

ğŸ® **OYUNLAR:**
â€¢ Toplam Oyun: {total_games:,}
â€¢ BugÃ¼n Oynanan: {games_today:,}
â€¢ Ortalama/KullanÄ±cÄ±: {total_games//total_users if total_users > 0 else 0:.1f}

ğŸ» **FÄ°NANSAL:**
â€¢ Toplam Para: {total_coins:,} ğŸ»
â€¢ Toplam Bahis: {total_bets:,} ğŸ»
â€¢ Toplam KazanÃ§: {total_winnings:,} ğŸ»
â€¢ House Edge: %{house_edge:.2f}

ğŸ¯ **AKTÄ°F Ä°Ã‡ERÄ°K:**
â€¢ Bekleyen DÃ¼ello: {active_duels}
â€¢ AÃ§Ä±k Turnuva: {active_tournaments}

ğŸ† **TOP 5 OYUNCU:**
"""
        
        for i, player in enumerate(top_players, 1):
            text += f"{i}. {player['username'] or 'Anonim'}: {player['fun_coins']:,} ğŸ»\n"
        
        text += f"""

âš¡ **PERFORMANS:**
â€¢ Bot Ã‡alÄ±ÅŸma SÃ¼resi: Online âœ…
â€¢ VeritabanÄ± Boyutu: ~{total_users * 2}KB
â€¢ Son GÃ¼ncellenme: BugÃ¼n
        """
        
        buttons = [
            [("ğŸ”„ Yenile", "admin_stats"), ("ğŸ“ˆ DetaylÄ± Rapor", "admin_detailed_stats")],
            [("ğŸ‘¥ KullanÄ±cÄ± YÃ¶netimi", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        try:
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        except Exception as edit_error:
            # Ignore "message not modified" errors
            if "Message is not modified" in str(edit_error):
                logger.debug("Admin statistics: Message content unchanged, skipping update")
            else:
                raise edit_error
        
    except Exception as e:
        logger.error(f"Admin statistics error: {e}")
        try:
            await query.edit_message_text(
                "âŒ **Ä°statistik HatasÄ±**\n\nğŸ”„ Please try again.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ”§ Admin Panel", "admin_panel"), ("ğŸ  Main Menu", "main_menu")]])
            )
        except:
            pass

async def show_admin_user_management(query, user, casino_bot):
    """Show user management interface"""
    try:
        with casino_bot.db.get_connection() as conn:
            # Recent users
            recent_users = conn.execute('''
                SELECT user_id, username, fun_coins, level, last_active 
                FROM users 
                ORDER BY last_active DESC 
                LIMIT 10
            ''').fetchall()
            
            # Problem users (negative balance, high activity, etc.)
            problem_users = conn.execute('''
                SELECT user_id, username, fun_coins 
                FROM users 
                WHERE fun_coins < 0 OR fun_coins > 10000000
                LIMIT 5
            ''').fetchall()
        
        text = """
ğŸ‘¥ **KULLANICI YÃ–NETÄ°MÄ°** ğŸ‘¥

ğŸ” **ARAMA VE FÄ°LTRELEME:**
â€¢ User ID ile arama
â€¢ Username ile arama
â€¢ Bakiye aralÄ±ÄŸÄ± filtresi
â€¢ Aktivite durumu filtresi

ğŸ“‹ **SON AKTÄ°F KULLANICILAR:**

"""
        
        for i, user_data in enumerate(recent_users[:5], 1):
            status = "ğŸŸ¢" if user_data['last_active'] else "ğŸ”´"
            username = user_data['username'] or f'User{user_data["user_id"]}'
            text += f"{i}. {status} {username}\n"
            text += f"   ğŸ» {user_data['fun_coins']:,} ğŸ» | Lv.{user_data['level']}\n\n"
        
        if problem_users:
            text += "âš ï¸ **DÄ°KKAT GEREKTÄ°REN KULLANICILAR:**\n\n"
            for prob_user in problem_users:
                username = prob_user['username'] or f'User{prob_user["user_id"]}'
                text += f"ğŸš¨ {username}\n"
                text += f"   ğŸ» {prob_user['fun_coins']:,} ğŸ»\n\n"
        
        text += """
âš™ï¸ **YÃ–NETÄ°M Ä°ÅLEMLERÄ°:**
â€¢ Para ekleme/Ã§Ä±karma
â€¢ Hesap sÄ±fÄ±rlama
â€¢ KullanÄ±cÄ± yasaklama
â€¢ Seviye dÃ¼zenleme
â€¢ Achievementm verme

ğŸ’¡ **KullanÄ±cÄ± ID girerek iÅŸlem yapabilirsiniz.**
        """
        
        buttons = [
            [("ğŸ” KullanÄ±cÄ± Ara", "admin_search_user"), ("ğŸ“Š DetaylÄ± Liste", "admin_user_list")],
            [("ğŸ» Para Ä°ÅŸlemleri", "admin_money_ops"), ("ğŸš« Yasaklama", "admin_ban_ops")],
            [("ğŸ”„ Yenile", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Admin user management error: {e}")

async def show_admin_broadcast_menu(query, user, casino_bot):
    """Show broadcast message interface"""
    try:
        with casino_bot.db.get_connection() as conn:
            total_users = conn.execute('SELECT COUNT(*) FROM users').fetchone()[0]
            active_users = conn.execute('''
                SELECT COUNT(*) FROM users 
                WHERE date(last_active) >= date('now', '-7 days')
            ''').fetchone()[0]
        
        text = f"""
ğŸ“¢ **DUYURU SÄ°STEMÄ°** ğŸ“¢

ğŸ“Š **HEDEFLENEBÄ°LÄ°R KULLANICILAR:**
â€¢ Toplam KullanÄ±cÄ±: {total_users:,}
â€¢ Active (7 gÃ¼n): {active_users:,}
â€¢ Tahmini UlaÅŸÄ±m: %85-95

ğŸ¯ **DUYURU TÃœRLERÄ°:**

ğŸ“£ **Genel Duyuru**
â€¢ TÃ¼m kullanÄ±cÄ±lara gÃ¶nderilir
â€¢ Sistem bildirimleri iÃ§in ideal
â€¢ Etkinlik duyurularÄ±

ğŸ”§ **BakÄ±m Bildirimi**
â€¢ Sistem bakÄ±m mesajÄ±
â€¢ Otomatik format
â€¢ SÃ¼re bildirimi

ğŸ‰ **Etkinlik Duyurusu**
â€¢ Ã–zel etkinlik formatÄ±
â€¢ Bonus bilgileri
â€¢ KatÄ±lÄ±m Ã§aÄŸrÄ±sÄ±

âš ï¸ **UYARI:** 
â€¢ Duyurular geri alÄ±namaz!
â€¢ Spam yapmayÄ±n
â€¢ Net ve aÃ§Ä±k yazÄ±n

ğŸ’¡ **Ä°pucu:** KÄ±sa ve etkili mesajlar daha iyi sonuÃ§ verir.
        """
        
        buttons = [
            [("ğŸ“£ Genel Duyuru", "admin_broadcast_general"), ("ğŸ”§ BakÄ±m Bildirimi", "admin_broadcast_maintenance")],
            [("ğŸ‰ Etkinlik Duyurusu", "admin_broadcast_event"), ("ğŸ“Š Hedefli Mesaj", "admin_broadcast_targeted")],
            [("ğŸ“ Ã–zel Mesaj", "admin_broadcast_custom"), ("ğŸ“‹ Mesaj GeÃ§miÅŸi", "admin_broadcast_history")],
            [("ğŸ”„ Yenile", "admin_broadcast"), ("ğŸ”§ Admin Panel", "admin_panel")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Admin broadcast menu error: {e}")

async def handle_admin_user_action(query, user, action, target_user_id, casino_bot):
    """Handle admin actions on users"""
    try:
        from advanced_features import admin_panel
        
        if not admin_panel:
            await query.edit_message_text(
                "âŒ Admin sistemi kullanÄ±lamÄ±yor.",
                reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
            )
            return
        
        # Get target user info
        target_user = casino_bot.get_user(target_user_id)
        if not target_user:
            await query.edit_message_text(
                f"âŒ KullanÄ±cÄ± bulunamadÄ±: {target_user_id}",
                reply_markup=casino_bot.create_keyboard([[("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users")]])
            )
            return
        
        username = target_user['username'] or f"User{target_user_id}"
        
        if action == "info":
            text = f"""
ğŸ‘¤ **KULLANICI BÄ°LGÄ°LERÄ°** ğŸ‘¤

ğŸ†” **ID:** {target_user_id}
ğŸ‘¤ **Username:** {username}
ğŸ» **Bakiye:** {target_user['fun_coins']:,} ğŸ»
ğŸ† **Level:** {target_user['level']}
â­ **XP:** {target_user['xp']:,}
ğŸ”¥ **Win Streak:** {target_user['win_streak']}
ğŸ® **Toplam Oyun:** {target_user['games_count']}
ğŸ’¸ **Toplam Bahis:** {target_user['total_bet']:,} ğŸ»
ğŸ’ **Toplam KazanÃ§:** {target_user['total_won']:,} ğŸ»
ğŸ“… **Son Active:** {target_user['last_active'] if 'last_active' in target_user else 'Bilinmiyor'}
ğŸ†” **ArkadaÅŸ Kodu:** {target_user['friend_code'] if 'friend_code' in target_user and target_user['friend_code'] else 'None'}

âš™ï¸ **YÃ–NETÄ°M Ä°ÅLEMLERÄ°:**
            """
            
            buttons = [
                [("ğŸ» +10K ğŸ»", f"admin_user_addmoney_{target_user_id}"), ("ğŸ’¸ -5K ğŸ»", f"admin_user_removemoney_{target_user_id}")],
                [("ğŸ”„ Hesap SÄ±fÄ±rla", f"admin_user_reset_{target_user_id}"), ("ğŸš« Yasakla", f"admin_user_ban_{target_user_id}")],
                [("ğŸ† Level +1", f"admin_user_levelup_{target_user_id}"), ("â­ +1000 XP", f"admin_user_addxp_{target_user_id}")],
                [("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")]
            ]
            
        elif action == "addmoney":
            result = admin_panel.manage_user(user['user_id'], target_user_id, "add_coins", 10000)
            if result["success"]:
                text = f"âœ… {username} hesabÄ±na 10,000 ğŸ» eklendi!"
            else:
                text = f"âŒ Ä°ÅŸlem baÅŸarÄ±sÄ±z: {result['error']}"
            
            buttons = [
                [("ğŸ‘¤ KullanÄ±cÄ± Bilgisi", f"admin_user_info_{target_user_id}")],
                [("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")]
            ]
            
        elif action == "removemoney":
            result = admin_panel.manage_user(user['user_id'], target_user_id, "remove_coins", 5000)
            if result["success"]:
                text = f"âœ… {username} hesabÄ±ndan 5,000 ğŸ» Ã§Ä±karÄ±ldÄ±!"
            else:
                text = f"âŒ Ä°ÅŸlem baÅŸarÄ±sÄ±z: {result['error']}"
            
            buttons = [
                [("ğŸ‘¤ KullanÄ±cÄ± Bilgisi", f"admin_user_info_{target_user_id}")],
                [("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")]
            ]
            
        elif action == "reset":
            result = admin_panel.manage_user(user['user_id'], target_user_id, "reset_user")
            if result["success"]:
                text = f"âœ… {username} hesabÄ± sÄ±fÄ±rlandÄ±!"
            else:
                text = f"âŒ Ä°ÅŸlem baÅŸarÄ±sÄ±z: {result['error']}"
            
            buttons = [
                [("ğŸ‘¤ KullanÄ±cÄ± Bilgisi", f"admin_user_info_{target_user_id}")],
                [("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")]
            ]
            
        else:
            text = f"âŒ GeÃ§ersiz iÅŸlem: {action}"
            buttons = [
                [("ğŸ‘¥ KullanÄ±cÄ±lar", "admin_users"), ("ğŸ”§ Admin Panel", "admin_panel")]
            ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Admin user action error: {e}")

# Missing duel game function
async def start_duel_game(query, game_id, user, casino_bot):
    """Start and complete a duel game"""
    try:
        with casino_bot.db.get_connection() as conn:
            game = conn.execute('SELECT * FROM active_games WHERE game_id = ?', (game_id,)).fetchone()
            if not game:
                return
            
            players = json.loads(game['players'])
            if len(players) != 2:
                return
            
            player1_id, player2_id = players[0], players[1]
            player1 = casino_bot.get_user(player1_id)
            player2 = casino_bot.get_user(player2_id)
            
            bet_amount = game['bet_amount']
            game_type = game['game_type']
            
            # Play the specific duel game
            result = None
            if game_type == 'duel_coinflip':
                p1_choice = random.choice(['heads', 'tails'])
                p2_choice = random.choice(['heads', 'tails'])
                flip_result = random.choice(['heads', 'tails'])
                
                if p1_choice == flip_result and p2_choice != flip_result:
                    winner = 1
                elif p2_choice == flip_result and p1_choice != flip_result:
                    winner = 2
                else:
                    winner = 0  # Tie
                
                result_text = f"""
ğŸª™ **COIN FLIP DÃœELLO SONUCU** ğŸª™

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ‘¤ **{player1['username'] or f'Oyuncu{player1_id}'}:** {p1_choice}
ğŸ‘¤ **{player2['username'] or f'Oyuncu{player2_id}'}:** {p2_choice}

ğŸª™ **SonuÃ§:** {flip_result.upper()}!

"""
                
            elif game_type.startswith('duel_dice'):
                # Extract dice type from game_type
                if game_type == 'duel_dice':
                    dice_type = 'standard'
                    dice_emoji = 'ğŸ²'
                elif game_type == 'duel_dice_standard':
                    dice_type = 'standard'
                    dice_emoji = 'ğŸ²'
                elif game_type == 'duel_dice_basketball':
                    dice_type = 'basketball'
                    dice_emoji = 'ğŸ€'
                elif game_type == 'duel_dice_football':
                    dice_type = 'football'
                    dice_emoji = 'âš½'
                elif game_type == 'duel_dice_slot':
                    dice_type = 'slot_machine'
                    dice_emoji = 'ğŸ°'
                elif game_type == 'duel_dice_bowling':
                    dice_type = 'bowling'
                    dice_emoji = 'ğŸ³'
                elif game_type == 'duel_dice_darts':
                    dice_type = 'darts'
                    dice_emoji = 'ğŸ¯'
                else:
                    dice_type = 'standard'
                    dice_emoji = 'ğŸ²'
                
                # Use game engine for dice duel
                from game_engine import GameEngine
                dice_result = GameEngine.play_duel_dice_with_type(dice_type.replace('_machine', ''))
                
                p1_dice = dice_result['dice1']
                p2_dice = dice_result['dice2']
                winner = dice_result['winner']
                
                game_name = {
                    'standard': 'STANDART ZAR',
                    'basketball': 'BASKETBOL ZAR',
                    'football': 'FUTBOL ZAR',
                    'slot_machine': 'SLOT ZAR',
                    'bowling': 'BOWLING ZAR',
                    'darts': 'DART ZAR'
                }.get(dice_type, 'ZAR BATTLE')
                
                result_text = f"""
{dice_emoji} **{game_name} DÃœELLO SONUCU** {dice_emoji}

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ‘¤ **{player1['username'] or f'Oyuncu{player1_id}'}:** {dice_emoji} {p1_dice}
ğŸ‘¤ **{player2['username'] or f'Oyuncu{player2_id}'}:** {dice_emoji} {p2_dice}

"""
                
            elif game_type == 'duel_rockpaper':
                choices = ['rock', 'paper', 'scissors']
                p1_choice = random.choice(choices)
                p2_choice = random.choice(choices)
                
                choice_emojis = {'rock': 'ğŸ—¿', 'paper': 'ğŸ“„', 'scissors': 'âœ‚ï¸'}
                
                # Determine winner
                if p1_choice == p2_choice:
                    winner = 0  # Tie
                elif (p1_choice == 'rock' and p2_choice == 'scissors') or \
                     (p1_choice == 'paper' and p2_choice == 'rock') or \
                     (p1_choice == 'scissors' and p2_choice == 'paper'):
                    winner = 1
                else:
                    winner = 2
                
                result_text = f"""
âœŠ **ROCK-PAPER-SCISSORS SONUCU** âœŠ

ğŸ® **Bahis:** {bet_amount:,} ğŸ»
ğŸ‘¤ **{player1['username'] or f'Oyuncu{player1_id}'}:** {choice_emojis[p1_choice]} {p1_choice}
ğŸ‘¤ **{player2['username'] or f'Oyuncu{player2_id}'}:** {choice_emojis[p2_choice]} {p2_choice}

"""
            
            # Determine final result and distribute winnings
            if winner == 1:
                result_text += f"ğŸ† **KAZANAN: {player1['username'] or f'Oyuncu{player1_id}'}!**\n"
                result_text += f"ğŸ» **KazanÃ§:** {bet_amount * 2:,} ğŸ»\n"
                
                # Update balances
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?',
                           (bet_amount * 2, player1_id))
                
                # Update stats
                casino_bot.update_user_stats(player1_id, bet_amount, bet_amount * 2, True)
                casino_bot.update_user_stats(player2_id, bet_amount, 0, False)
                
            elif winner == 2:
                result_text += f"ğŸ† **KAZANAN: {player2['username'] or f'Oyuncu{player2_id}'}!**\n"
                result_text += f"ğŸ» **KazanÃ§:** {bet_amount * 2:,} ğŸ»\n"
                
                # Update balances
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?',
                           (bet_amount * 2, player2_id))
                
                # Update stats
                casino_bot.update_user_stats(player1_id, bet_amount, 0, False)
                casino_bot.update_user_stats(player2_id, bet_amount, bet_amount * 2, True)
                
            else:
                result_text += "ğŸ¤ **BERABERE!**\n"
                result_text += f"ğŸ» **Para Ä°adesi:** {bet_amount:,} ğŸ» (her oyuncuya)\n"
                
                # Refund bets
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?',
                           (bet_amount, player1_id))
                conn.execute('UPDATE users SET fun_coins = fun_coins + ? WHERE user_id = ?',
                           (bet_amount, player2_id))
                
                # Update stats (no win/loss for ties)
                casino_bot.update_user_stats(player1_id, bet_amount, bet_amount, False)
                casino_bot.update_user_stats(player2_id, bet_amount, bet_amount, False)
            
            result_text += "\nğŸ¯ **BaÅŸka bir dÃ¼elloya hazÄ±r mÄ±sÄ±n?**"
            
            # Complete the duel
            casino_bot.complete_duel(game_id)
            conn.commit()
        
        buttons = [
            [("ğŸ”„ Yeni DÃ¼ello", "create_duel"), ("ğŸ¯ DÃ¼elloya KatÄ±l", "join_duel")],
            [("ğŸ® Solo Games", "solo_games"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Start duel game error: {e}")

# Missing handler functions - Added to fix button functionality issues

async def show_vip_info(query, user, bot_instance):
    """Show VIP information and benefits"""
    try:
        vip_level = bot_instance.get_user_vip_level(user['user_id'])
        
        from config import VIP_LEVELS
        
        text = f"""
ğŸ‘‘ **VIP BÄ°LGÄ°LERÄ°** ğŸ‘‘

ğŸŒŸ **Mevcut Seviye:** {"VIP " + str(vip_level) if vip_level > 0 else "Standart"}

ğŸ’ **VIP Advantages:**
"""
        
        if vip_level > 0:
            vip_data = VIP_LEVELS[vip_level]
            text += f"""
ğŸ”¥ **VIP {vip_level} Advantages:**
â€¢ ğŸ» Daily Bonus: +{vip_data['daily_bonus']} ğŸ»
â€¢ ğŸ¯ Maksimum Bahis: {vip_data['max_bet']:,} ğŸ»
â€¢ ğŸš€ Bonus Multiplier: {vip_data['multiplier_bonus']}x
â€¢ ğŸ Ã–zel Bonuslar
â€¢ âš¡ Ã–ncelikli Destek
"""
        else:
            text += """
ğŸ†• **Standart Hesap:**
â€¢ ğŸ» Daily Bonus: 50-200 ğŸ»
â€¢ ğŸ¯ Maksimum Bahis: 100,000 ğŸ»
â€¢ ğŸš€ Standart Multiplierlar

ğŸ‘‘ **Become VIPmak iÃ§in:**
â€¢ YatÄ±rÄ±m yapÄ±n ve VIP seviyenizi yÃ¼kseltin!
â€¢ Her seviye yeni avantajlar getirir
"""
        
        buttons = [
            [("ğŸ’³ YatÄ±rÄ±m Yap", "deposit_menu"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ® Play Game", "solo_games"), ("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = bot_instance.casino.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"VIP info error: {e}")
        await query.edit_message_text(
            "âŒ VIP bilgileri yÃ¼klenirken error occurred.",
            reply_markup=bot_instance.casino.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_game_history(query, user, casino_bot):
    """Show user's game history"""
    try:
        with casino_bot.db.get_connection() as conn:
            games = conn.execute('''
                SELECT game_type, bet_amount, win_amount, won, played_at
                FROM solo_game_history 
                WHERE user_id = ? 
                ORDER BY played_at DESC LIMIT 10
            ''', (user['user_id'],)).fetchall()
        
        if not games:
            text = """
ğŸ“Š **OYUN GEÃ‡MÄ°ÅÄ°** ğŸ“Š

ğŸ“ HenÃ¼z oyun geÃ§miÅŸin yok!

ğŸ® Hemen oyun oynamaya baÅŸla:
            """
            buttons = [
                [("ğŸ® Solo Games", "solo_games"), ("ğŸ¯ DÃ¼ello", "create_duel")],
                [("ğŸ  Main Menu", "main_menu")]
            ]
        else:
            text = """
ğŸ“Š **OYUN GEÃ‡MÄ°ÅÄ°** ğŸ“Š

ğŸ¯ **Son 10 Oyunun:**

"""
            for game in games:
                status = "ğŸ† KAZANDIN" if game['won'] else "ğŸ’¸ Kaybettin"
                game_name = game['game_type'].replace('solo_', '').title()
                text += f"â€¢ {status} - {game_name} - {game['bet_amount']:,} ğŸ» â†’ {game['win_amount']:,} ğŸ»\n"
            
            total_games = len(games)
            wins = sum(1 for g in games if g['won'])
            win_rate = (wins / total_games * 100) if total_games > 0 else 0
            
            text += f"""
ğŸ“ˆ **Statistics:**
â€¢ Toplam Oyun: {total_games}
â€¢ Win Rate: {win_rate:.1f}%
            """
            
            buttons = [
                [("ğŸ® Daha Fazla Oyna", "solo_games"), ("ğŸ“Š Profil", "profile")],
                [("ğŸ  Main Menu", "main_menu")]
            ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Game history error: {e}")
        await query.edit_message_text(
            "âŒ Oyun geÃ§miÅŸi yÃ¼klenirken error occurred.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_settings_menu(query, user, casino_bot):
    """Show settings menu"""
    try:
        text = """
âš™ï¸ **AYARLAR** âš™ï¸

ğŸ”§ **Mevcut Ayarlar:**

ğŸŒ **Dil:** TÃ¼rkÃ§e
ğŸ”” **Bildirimler:** AÃ§Ä±k
ğŸµ **Sesler:** AÃ§Ä±k
ğŸ‘¤ **Profil:** Herkese AÃ§Ä±k

âš¡ **HÄ±zlÄ± Ayarlar:**
        """
        
        buttons = [
            [("ğŸŒ Dil DeÄŸiÅŸtir", "language"), ("ğŸ”” Bildirimler", "notifications")],
            [("ğŸ‘¤ Gizlilik", "privacy"), ("ğŸ“Š Profil", "profile")],
            [("ğŸ  Main Menu", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Settings menu error: {e}")
        await query.edit_message_text(
            "âŒ Ayarlar yÃ¼klenirken error occurred.",
            reply_markup=casino_bot.create_keyboard([[("ğŸ  Main Menu", "main_menu")]])
        )

async def show_notifications_settings(query, user, casino_bot):
    """Show notification settings"""
    text = """
ğŸ”” **BÄ°LDÄ°RÄ°M AYARLARI** ğŸ””

ğŸ“± **Bildirim TÃ¼rleri:**
â€¢ ğŸ Daily Bonus HatÄ±rlatÄ±cÄ±: âœ…
â€¢ ğŸ® Oyun Daveteleri: âœ…  
â€¢ ğŸ‘¥ ArkadaÅŸ Ä°stekleri: âœ…
â€¢ ğŸ† Achievementm Bildirimleri: âœ…
â€¢ ğŸ» Bakiye UyarÄ±larÄ±: âœ…

âš¡ **HÄ±zlÄ± Ayarlar:**
    """
    
    buttons = [
        [("ğŸ”• TÃ¼mÃ¼nÃ¼ Kapat", "notifications_off"), ("ğŸ”” TÃ¼mÃ¼nÃ¼ AÃ§", "notifications_on")],
        [("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]
    ]
    
    keyboard = casino_bot.create_keyboard(buttons)
    await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')

async def show_privacy_settings(query, user, casino_bot):
    """Show privacy settings"""
    text = """
ğŸ‘¤ **GÄ°ZLÄ°LÄ°K AYARLARI** ğŸ‘¤

ğŸ”’ **Gizlilik SeÃ§enekleri:**
â€¢ ğŸ“Š Profil GÃ¶rÃ¼nÃ¼rlÃ¼ÄŸÃ¼: Herkese AÃ§Ä±k
â€¢ ğŸ® Oyun Durumu: GÃ¶rÃ¼nÃ¼r
â€¢ ğŸ‘¥ ArkadaÅŸ Listesi: YalnÄ±zca ArkadaÅŸlar
â€¢ ğŸ“ˆ Statistics: Herkese AÃ§Ä±k
â€¢ ğŸ† Achievementmlar: Herkese AÃ§Ä±k

ğŸ›¡ï¸ **GÃ¼venlik:**
    """
    
    buttons = [
        [("ğŸ”’ Ã–zel Yap", "privacy_private"), ("ğŸŒ Herkese AÃ§", "privacy_public")],
        [("âš™ï¸ Back to Settings", "settings"), ("ğŸ  Main Menu", "main_menu")]
    ]
    
    keyboard = casino_bot.create_keyboard(buttons)
    await query.edit_message_text(text, reply_markup=keyboard, parse_mode='Markdown')


# Import required modules at the top
import asyncio
import random
import json

# TÃ¼m solo oyunlar iÃ§in handler fonksiyonlarÄ±
async def handle_solo_game_menu(query, user, casino_bot, game_type, game_name):
    """Mevcut solo oyunlar iÃ§in bahis menÃ¼sÃ¼ gÃ¶sterir"""
    try:
        balance = user['fun_coins']
        
        bet_text = f"""
ğŸ® **{game_name}**

ğŸ’° **Bakiyeniz:** {balance:,} ğŸ»

Bahis miktarÄ±nÄ±zÄ± seÃ§in:
        """
        
        # Dinamik bahis butonlarÄ±
        bet_amounts = []
        if balance >= 10:
            bet_amounts.append(10)
        if balance >= 50:
            bet_amounts.append(50)
        if balance >= 100:
            bet_amounts.append(100)
        if balance >= 500:
            bet_amounts.append(500)
        if balance >= 1000:
            bet_amounts.append(1000)
        if balance >= 5000:
            bet_amounts.append(5000)
        
        if not bet_amounts:
            await query.edit_message_text(
                "âŒ Yetersiz bakiye! En az 10 ğŸ» gerekli.",
                reply_markup=casino_bot.create_keyboard([
                    [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ])
            )
            return
            
        buttons = []
        for i in range(0, len(bet_amounts), 2):
            row = []
            for j in range(2):
                if i + j < len(bet_amounts):
                    amount = bet_amounts[i + j]
                    # game_type'dan solo_ prefix'ini kaldÄ±r
                    clean_game_type = game_type.replace("solo_", "")
                    row.append((f"ğŸ’° {amount} ğŸ»", f"play_game_{clean_game_type}_{amount}"))
            buttons.append(row)
        
        buttons.append([("ğŸ”™ Geri", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")])
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(bet_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Solo game menu error: {e}")

async def handle_solo_game_play(query, user, casino_bot, game_type, bet_amount):
    """Mevcut solo oyunlarÄ± oynatÄ±r"""
    try:
        from solo_games import SoloGameEngine
        
        # Bahis doÄŸrulama
        if user['fun_coins'] < bet_amount:
            await query.edit_message_text(
                "âŒ Yetersiz bakiye!",
                reply_markup=casino_bot.create_keyboard([
                    [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ])
            )
            return
        
        # Oyunu oyna
        solo_engine = SoloGameEngine()
        full_game_type = f"solo_{game_type}"
        
        if game_type == "slots":
            result = solo_engine.play_solo_slots(bet_amount, user['user_id'])
        elif game_type == "roulette":
            result = solo_engine.play_solo_roulette(bet_amount, "color", "red", user['user_id'])
        elif game_type == "blackjack":
            result = solo_engine.play_solo_blackjack(bet_amount, user['user_id'])
        elif game_type == "crash":
            result = solo_engine.play_solo_crash(bet_amount, 2.0, user['user_id'])
        elif game_type == "mines":
            result = solo_engine.play_solo_mines(bet_amount, 3, 5, user['user_id'])
        elif game_type == "baccarat":
            result = solo_engine.play_solo_baccarat(bet_amount, "player", user['user_id'])
        elif game_type == "keno":
            result = solo_engine.play_solo_keno(bet_amount, [1, 2, 3, 4, 5], user['user_id'])
        elif game_type == "dice":
            result = solo_engine.play_solo_dice(bet_amount, 4, user['user_id'])
        else:
            await query.edit_message_text("âŒ Bilinmeyen oyun tÃ¼rÃ¼!")
            return
        
        # Bakiye gÃ¼ncelle
        old_balance = user['fun_coins']
        new_balance = old_balance - bet_amount + result['win_amount']
        casino_bot.update_user_balance(user['user_id'], new_balance)
        
        # SonuÃ§ mesajÄ±
        if result['won']:
            status_emoji = "ğŸ‰"
            status_text = "KAZANDINIZ!"
        else:
            status_emoji = "ğŸ˜”"
            status_text = "Kaybettiniz"
        
        # Oyun detaylarÄ±nÄ± ekle
        game_details = ""
        if game_type == "slots" and 'reels' in result:
            game_details = f"\nğŸ° **SonuÃ§:** {' | '.join(result['reels'])}"
        elif game_type == "roulette" and 'number' in result:
            game_details = f"\nğŸ”´ **SayÄ±:** {result['number']} {result.get('color_emoji', '')}"
        elif game_type == "blackjack":
            game_details = f"\nâ™ ï¸ **Sizin kartlarÄ±nÄ±z:** {result.get('player_value', 0)}\nğŸ² **Krupiye:** {result.get('dealer_value', 0)}"
        elif game_type == "crash" and 'crash_point' in result:
            game_details = f"\nğŸš€ **Crash NoktasÄ±:** {result['crash_point']}x"
        elif game_type == "dice" and 'dice_result' in result:
            game_details = f"\nğŸ² **Zar Sonucu:** {result.get('dice_emoji', '')} {result['dice_result']}"
        
        result_text = f"""
{status_emoji} **{status_text}** {status_emoji}

{result.get('special_effect', '')}

{result['result_text']}
{game_details}

ğŸ’° **Bahis:** {bet_amount:,} ğŸ»
ğŸ **KazanÃ§:** {result['win_amount']:,} ğŸ»
ğŸ“Š **Eski Bakiye:** {old_balance:,} ğŸ»
ğŸ“Š **Yeni Bakiye:** {new_balance:,} ğŸ»
        """
        
        buttons = [
            [("ğŸ”„ Tekrar Oyna", f"play_solo_{game_type}"), ("ğŸ® DiÄŸer Oyunlar", "games")],
            [("ğŸ“Š Profil", "profile"), ("ğŸ  Ana MenÃ¼", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
        # Ä°statistikleri kaydet
        casino_bot.save_solo_game(user['user_id'], full_game_type, bet_amount, result)
        
    except Exception as e:
        logger.error(f"Solo game play error: {e}")
        await query.edit_message_text(
            f"âŒ Oyun oynanÄ±rken hata oluÅŸtu: {e}",
            reply_markup=casino_bot.create_keyboard([
                [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
            ])
        )

async def show_user_stats(query, user, casino_bot):
    """KullanÄ±cÄ± istatistiklerini gÃ¶sterir"""
    try:
        # KullanÄ±cÄ± verilerini al
        user_id = user['user_id']
        
        # VeritabanÄ±ndan oyun istatistiklerini al
        with casino_bot.db.get_connection() as conn:
            # Toplam oyun sayÄ±sÄ±
            total_games = conn.execute(
                'SELECT COUNT(*) FROM solo_game_history WHERE user_id = ?', 
                (user_id,)
            ).fetchone()[0]
            
            # Toplam bahis miktarÄ±
            total_bet = conn.execute(
                'SELECT SUM(bet_amount) FROM solo_game_history WHERE user_id = ?', 
                (user_id,)
            ).fetchone()[0] or 0
            
            # Toplam kazanÃ§
            total_winnings = conn.execute(
                'SELECT SUM(win_amount) FROM solo_game_history WHERE user_id = ?', 
                (user_id,)
            ).fetchone()[0] or 0
            
            # KazanÄ±lan oyun sayÄ±sÄ±
            won_games = conn.execute(
                'SELECT COUNT(*) FROM solo_game_history WHERE user_id = ? AND win_amount > bet_amount',
                (user_id,)
            ).fetchone()[0]
            
            # En Ã§ok oynanan oyun
            favorite_game = conn.execute('''
                SELECT game_type, COUNT(*) as count FROM solo_game_history 
                WHERE user_id = ? 
                GROUP BY game_type 
                ORDER BY count DESC 
                LIMIT 1
            ''', (user_id,)).fetchone()
            
            # En yÃ¼ksek kazanÃ§
            highest_win = conn.execute(
                'SELECT MAX(win_amount) FROM solo_game_history WHERE user_id = ?',
                (user_id,)
            ).fetchone()[0] or 0
        
        # Win rate hesapla
        win_rate = (won_games / total_games * 100) if total_games > 0 else 0
        net_profit = total_winnings - total_bet
        
        # Seviye hesapla (basit sistem)
        level = min(50, max(1, total_games // 10 + 1))
        
        # Prepare conditional values to avoid markdown issues
        profit_emoji = "ğŸ’š" if net_profit >= 0 else "â¤ï¸"
        
        # Achievement emojis and titles
        if total_games >= 100:
            games_emoji = "ğŸ¥‡"
            games_title = "Deneyimli"
        elif total_games >= 10:
            games_emoji = "ğŸ¥‰"  
            games_title = "Yeni BaÅŸlayan"
        else:
            games_emoji = "ğŸ”°"
            games_title = "Acemi"
            
        if win_rate >= 60:
            winrate_emoji = "ğŸ’"
            winrate_title = "ÅanslÄ±"
        elif win_rate >= 40:
            winrate_emoji = "ğŸ¯"
            winrate_title = "Dengeli" 
        else:
            winrate_emoji = "ğŸ€"
            winrate_title = "GeliÅŸen"
        
        # Favorite game info
        fav_game_text = f"{favorite_game[0]} ({favorite_game[1]} kez)" if favorite_game else "HenÃ¼z oyun oynamamÄ±ÅŸ (0 kez)"

        # Escape markdown characters and simplify formatting
        escaped_username = user['username'].replace('*', '\\*').replace('_', '\\_').replace('[', '\\[').replace('`', '\\`')
        escaped_fav_game = fav_game_text.replace('*', '\\*').replace('_', '\\_').replace('[', '\\[').replace('`', '\\`')

        stats_text = f"""ğŸ“Š {escaped_username}'in Ä°statistikleri ğŸ“Š

ğŸ® Oyun Ä°statistikleri:
ğŸ¯ Toplam Oyun: {total_games:,}
ğŸ† KazanÄ±lan: {won_games:,}
ğŸ“ˆ Kazanma OranÄ±: {win_rate:.1f}%
â­ Seviye: {level}

ğŸ’° Finansal Durum:
ğŸ» GÃ¼ncel Bakiye: {user['fun_coins']:,} ğŸ»
ğŸ’¸ Toplam Bahis: {total_bet:,} ğŸ»
ğŸ Toplam KazanÃ§: {total_winnings:,} ğŸ»
{profit_emoji} Net Kar/Zarar: {net_profit:+,} ğŸ»
ğŸ’ En BÃ¼yÃ¼k KazanÃ§: {highest_win:,} ğŸ»

ğŸ¯ Favori Oyun:
{escaped_fav_game}

ğŸ… BaÅŸarÄ±lar:
{games_emoji} {games_title} Oyuncu
{winrate_emoji} {winrate_title} Oyuncu"""
        
        # Check if we're in a group chat context to determine the right menu
        is_group = hasattr(query.message, 'chat') and query.message.chat.type in ['group', 'supergroup']
        games_button = ("ğŸ® Oyunlar", "games") if is_group else ("ğŸ® Solo Oyunlar", "solo_games")
        
        # Create keyboard based on context - no main menu button in group chats
        if is_group:
            keyboard = casino_bot.create_keyboard([
                [games_button, ("ğŸ“Š Leaderboard", "leaderboard")],
                [("ğŸ“ˆ Profil", "profile")]
            ])
        else:
            keyboard = casino_bot.create_keyboard([
                [games_button, ("ğŸ“Š Leaderboard", "leaderboard")],
                [("ğŸ“ˆ Profil", "profile"), ("ğŸ  Ana MenÃ¼", "main_menu")]
            ])
        
        await query.edit_message_text(stats_text, reply_markup=keyboard, parse_mode=None)
        
    except Exception as e:
        logger.error(f"Show user stats error: {e}")
        
        # Check if we're in a group chat context for error handling too
        is_group = hasattr(query.message, 'chat') and query.message.chat.type in ['group', 'supergroup']
        games_button = ("ğŸ® Oyunlar", "games") if is_group else ("ğŸ® Solo Oyunlar", "solo_games")
        
        # Create error keyboard based on context - no main menu button in group chats
        if is_group:
            error_keyboard = casino_bot.create_keyboard([[games_button]])
        else:
            error_keyboard = casino_bot.create_keyboard([[games_button, ("ğŸ  Ana MenÃ¼", "main_menu")]])
        
        await query.edit_message_text(
            "âŒ Ä°statistikler yÃ¼klenemedi!",
            reply_markup=error_keyboard
        )

# Yeni solo oyunlar iÃ§in handler fonksiyonlarÄ±
async def handle_new_solo_game_menu(query, user, casino_bot, game_type, game_name):
    """Yeni solo oyunlar iÃ§in bahis menÃ¼sÃ¼ gÃ¶sterir"""
    try:
        # Bahis miktarlarÄ±
        balance = user['fun_coins']
        
        bet_text = f"""
ğŸ® **{game_name}**

ğŸ’° **Bakiyeniz:** {balance:,} ğŸ»

Bahis miktarÄ±nÄ±zÄ± seÃ§in:
        """
        
        # Dinamik bahis butonlarÄ±
        bet_amounts = []
        if balance >= 10:
            bet_amounts.append(10)
        if balance >= 50:
            bet_amounts.append(50)
        if balance >= 100:
            bet_amounts.append(100)
        if balance >= 500:
            bet_amounts.append(500)
        if balance >= 1000:
            bet_amounts.append(1000)
        
        if not bet_amounts:
            await query.edit_message_text(
                "âŒ Yetersiz bakiye! En az 10 ğŸ» gerekli.",
                reply_markup=casino_bot.create_keyboard([
                    [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ])
            )
            return
            
        buttons = []
        for i in range(0, len(bet_amounts), 2):
            row = []
            for j in range(2):
                if i + j < len(bet_amounts):
                    amount = bet_amounts[i + j]
                    row.append((f"ğŸ’° {amount} ğŸ»", f"play_new_game_{game_type}_{amount}"))
            buttons.append(row)
        
        buttons.append([("ğŸ”™ Geri", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")])
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(bet_text, reply_markup=keyboard, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"New solo game menu error: {e}")

async def handle_new_solo_game_play(query, user, casino_bot, game_type, bet_amount):
    """Yeni solo oyunlarÄ± oynatÄ±r"""
    try:
        from solo_games import SoloGameEngine
        
        # Bahis doÄŸrulama
        if user['fun_coins'] < bet_amount:
            await query.edit_message_text(
                "âŒ Yetersiz bakiye!",
                reply_markup=casino_bot.create_keyboard([
                    [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
                ])
            )
            return
        
        # Oyunu oyna
        solo_engine = SoloGameEngine()
        
        if game_type == "rock_paper_scissors":
            result = solo_engine.play_rock_paper_scissors(bet_amount, None, user['user_id'])
        elif game_type == "number_guess":
            result = solo_engine.play_number_guess(bet_amount, None, user['user_id'])
        elif game_type == "lucky_wheel":
            result = solo_engine.play_lucky_wheel(bet_amount, user['user_id'])
        else:
            await query.edit_message_text("âŒ Bilinmeyen oyun tÃ¼rÃ¼!")
            return
        
        # Bakiye gÃ¼ncelle
        old_balance = user['fun_coins']
        new_balance = old_balance - bet_amount + result['win_amount']
        casino_bot.update_user_balance(user['user_id'], new_balance)
        
        # SonuÃ§ mesajÄ±
        if result['won']:
            status_emoji = "ğŸ‰"
            status_text = "KAZANDINIZ!"
        else:
            status_emoji = "ğŸ˜”"
            status_text = "Kaybettiniz"
        
        result_text = f"""
{status_emoji} **{status_text}** {status_emoji}

{result.get('special_effect', '')}

{result['result_text']}

ğŸ’° **Bahis:** {bet_amount:,} ğŸ»
ğŸ **KazanÃ§:** {result['win_amount']:,} ğŸ»
ğŸ“Š **Eski Bakiye:** {old_balance:,} ğŸ»
ğŸ“Š **Yeni Bakiye:** {new_balance:,} ğŸ»
        """
        
        buttons = [
            [("ğŸ”„ Tekrar Oyna", f"play_{game_type}"), ("ğŸ® DiÄŸer Oyunlar", "games")],
            [("ğŸ“Š Profil", "profile"), ("ğŸ  Ana MenÃ¼", "main_menu")]
        ]
        
        keyboard = casino_bot.create_keyboard(buttons)
        await query.edit_message_text(result_text, reply_markup=keyboard, parse_mode='Markdown')
        
        # Ä°statistikleri kaydet
        casino_bot.save_solo_game(user['user_id'], f"new_{game_type}", bet_amount, result)
        
    except Exception as e:
        logger.error(f"New solo game play error: {e}")
        await query.edit_message_text(
            f"âŒ Oyun oynanÄ±rken hata oluÅŸtu: {e}",
            reply_markup=casino_bot.create_keyboard([
                [("ğŸ® Oyunlar", "games"), ("ğŸ  Ana MenÃ¼", "main_menu")]
            ])
        )

if __name__ == "__main__":
    # Set proper event loop policy for Windows
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
    
    # Run the main function
    main()